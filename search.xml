<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF1804D Accommodation 题解</title>
    <url>/2023/06/27/CF1804D-Accommodation-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/CF1804D">link</a></p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于行与行之间独立，所以可以对每行分别求最大和最小值。</p>
<p>先考虑最小值。</p>
<p>先找出每段 $1$ 的长度，显然是尽量往里面放双人房，如果所需双人房个数 $&gt;\dfrac{m}{4}$，那么就删掉一些双人房然后塞单人房即可。</p>
<p>然后是最大值。</p>
<p>设 $1$ 的个数为 $c$，那么答案就是 $c$ 减双人房中两个都是 $1$ 的房间个数。</p>
<p>考虑双人房中两个都是 $1$ 的最小房间个数怎么求，由于这个又等于 $\dfrac{m}{4}$ 减双人房中有至少一个为 $0$ 房间个数。</p>
<p>至少一个为 $0$ 的个数就从前往后扫，如果发现 $a_i+a_{i+1}&lt;2$ 就用双人房，然后跳到 $i+2$ 继续搞。</p>
<p>这样做显然是对的，证明如下：</p>
<p>考虑把 $0$ 和他们两边的 $1$ 的区间最边上的 $1$ 合并成一个大区间 $[l_i,r_i]$，如果两个 $0$ 区间中间只隔了 $1$ 个 $1$ 那么把他们也合并了。</p>
<p>容易发现区间不会相交。上面那个操作就是在每个区间里找最多不相交的二连线段个数，显然从前往后扫是最优的。</p>
<p>至少一个为 $0$ 的个数如果大于 $\dfrac{m}{4}$ 就取到 $\dfrac{m}{4}$。</p>
<p>时间复杂度：$O(nm)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[kMaxN], b[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt2 = m / <span class="number">4</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> lst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]) ++lst;</span><br><span class="line">    <span class="keyword">if</span> (!a[i + <span class="number">1</span>] &amp;&amp; lst) &#123;</span><br><span class="line">      b[++k] = lst, lst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    sum += b[i] / <span class="number">2</span>;</span><br><span class="line">    tot += b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum &lt;= cnt2) <span class="keyword">return</span> sum + tot - <span class="number">2</span> * sum;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> cnt2 + tot - <span class="number">2</span> * cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt2 = m / <span class="number">4</span>, k = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ret += a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i] || !a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      ++k, i += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret - (cnt2 - std::<span class="built_in">min</span>(cnt2, k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mi = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    mi += <span class="built_in">getmin</span>(s), mx += <span class="built_in">getmax</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; mi &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ORZXKR</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &#x27;s&#x27; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1804F Approximate Diameter 题解</title>
    <url>/2023/06/29/CF1804F-Approximate-Diameter-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个 $n$ 个点 $m$ 条边的初始无向图，有 $q$ 次更新，每次更新向图中添加一条边。设 $d(G_i)$ 代表加入 $i$ 条边后的图中两点之间的最大距离，你需要输出 $q+1$ 个整数 $a_0,a_1,\dots,a_q$，满足 $\left\lceil\dfrac{d(G_i)}{2}\right\rceil\le a_i\le 2\cdot d(G_i)$。</p>
<p>$n,m,q\le 10^5$，图连通。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先一个普通图的 $d$ 肯定是不好求的，这题也没有让求，考虑转化。</p>
<p>设 $s_i$ 表示加入 $1\sim i$ 条边，$1$ 到其他点的最长距离，易知 $s_i\leq d(G_i)$。</p>
<p>如果 $1$ 在 $G_i$ 的直径上，则必有 $s_i\geq\left\lceil\dfrac{d(G_i)}{2}\right\rceil$。如果不在直径上的话就先走到直径上，$s_i$ 只会变得更大。</p>
<p>所以 $\left\lceil\dfrac{d(G_i)}{2}\right\rceil\leq s_i\leq d(G_i)$。</p>
<p>显然 $s_i$ 是满足条件的 $a_i$，暴力求就可以做到 $O(n^2)$。</p>
<hr>
<p>观察到 $\left\lceil\dfrac{d(G_i)}{2}\right\rceil\leq s_i\leq d(G_i)$ 的右边界是没有卡满的，甚至只卡到了原来的 $\dfrac{1}{2}$，又因为左边界是递减的，所以考虑让 $s_i$ 代替后面的一部分 $s_j$。</p>
<p>考虑什么条件下 $i$ 能代替 $j(i\leq j)$。</p>
<p>根据上面的式子可得：$\left\lceil\dfrac{d(G_j)}{2}\right\rceil\leq s_j\leq d(G_j)$，$s_i\leq 2\times d(G_j)$。</p>
<p>所以当 $s_i\leq 2\times s_j$ 时 $i$ 能够代替 $j$，即 $s_j\geq \left\lceil\dfrac{s_i}{2}\right\rceil$。由于 $s_i$ 是递减的，所以可以二分 $j$ 找到 $i$ 能<strong>确保</strong>代替的最大的 $j$。</p>
<p>这样做每次 $s_j$ 相比 $s_i$ 会减半，所以最多会二分 $\log n$ 轮，每轮 $\log q$ 次，时间复杂度就是 $O(n\log n\log q)$。</p>
<p>注意：这里 $s_j&lt;\left\lceil\dfrac{s_i}{2}\right\rceil$ 不代表 $i$ 不能代替 $j$，不过不管它对结果没什么影响。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> u[kMaxN], v[kMaxN], s[kMaxN], d[kMaxN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[kMaxN], nG[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">fill</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + n, <span class="number">-1</span>);</span><br><span class="line">  std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">emplace</span>(<span class="number">1</span>), d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : nG[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!~d[v]) &#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(v), d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *std::<span class="built_in">max_element</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (~s[x]) <span class="keyword">return</span> s[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    nG[i] = G[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">    nG[u[i]].<span class="built_in">emplace_back</span>(v[i]), nG[v[i]].<span class="built_in">emplace_back</span>(u[i]);</span><br><span class="line">  <span class="keyword">return</span> s[x] = <span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v), G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    std::cin &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">  std::<span class="built_in">fill</span>(s, s + <span class="number">1</span> + q, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= q; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> L = i - <span class="number">1</span>, R = q + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">get</span>(mid) &gt;= (<span class="built_in">get</span>(i) + <span class="number">1</span>) / <span class="number">2</span>) L = j = mid;</span><br><span class="line">      <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">      std::cout &lt;&lt; <span class="built_in">get</span>(i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ORZXKR</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &#x27;s&#x27; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>思维</tag>
        <tag>二分</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P3573 [POI2014] RAJ-Rally 题解</title>
    <url>/2023/07/07/P3573-POI2014-RAJ-Rally-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个 $n$ 个点 $m$ 条边的有向无环图，每条边长度都是 $1$。</p>
<p>请找到一个点，使得删掉这个点后剩余的图中的最长路径最短。</p>
<p>$n\leq 5\times 10^5,m\leq 10^6$。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f_i$ 表示以 $i$ 为终点的最长路，$g_i$ 表示以 $i$ 为起点的最长路，$d_i$ 为 $i$ 的拓扑序。</p>
<p>这两个显然可以通过拓扑排序求出。</p>
<p>易知原图中的任何一个路径上的点的拓扑序一定是递增的，所以删掉一个点 $u$，剩余的路径只有 $f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)$ 三种可能。</p>
<p>那么就可以维护三个 multiset，分别维护 $f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)$。</p>
<p>前两个直接在从小到大枚举 $d_u$ 的时候增删，第三个可以每次先加入 $d_i&#x3D;d_u-1$ 的所有边，然后删去 $d_j&#x3D;d_u$ 的所有边，这样可以保证 $d_i&lt;d_u$ 且 $d_j&gt;d_u$。</p>
<p>时间复杂度：$O((n+m)\log (n+m))$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int int64_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> id[kMaxN], deg[kMaxN], f[kMaxN], g[kMaxN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[kMaxN], rG[kMaxN];</span><br><span class="line">std::multiset&lt;<span class="type">int</span>&gt; s1, s2, s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s1 : f[u]</span></span><br><span class="line"><span class="comment">// s2 : g[u]</span></span><br><span class="line"><span class="comment">// s3 : f[u] + g[v] + 1(u &lt; i &lt; v)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!deg[i]) &#123;</span><br><span class="line">      q.<span class="built_in">emplace</span>(i), f[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    id[++cnt] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">      f[v] = std::<span class="built_in">max</span>(f[v], f[u] + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!--deg[v])</span><br><span class="line">        q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v), rG[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    ++deg[v];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">topo</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i; --i) &#123;</span><br><span class="line">    <span class="type">int</span> u = id[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u])</span><br><span class="line">      g[u] = std::<span class="built_in">max</span>(g[u], g[v] + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s2.<span class="built_in">emplace</span>(-g[i]);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1e9</span>, idx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = id[i];</span><br><span class="line">    <span class="keyword">if</span> (i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[id[i - <span class="number">1</span>]])</span><br><span class="line">        s3.<span class="built_in">emplace</span>(-(f[id[i - <span class="number">1</span>]] + g[v] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : rG[u]) &#123;</span><br><span class="line">      s3.<span class="built_in">erase</span>(s3.<span class="built_in">lower_bound</span>(-(f[v] + g[u] + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i) s1.<span class="built_in">emplace</span>(-f[id[i - <span class="number">1</span>]]);</span><br><span class="line">    s2.<span class="built_in">erase</span>(s2.<span class="built_in">lower_bound</span>(-g[u]));</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!s1.<span class="built_in">empty</span>()) mx = std::<span class="built_in">max</span>(mx, -*s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s2.<span class="built_in">empty</span>()) mx = std::<span class="built_in">max</span>(mx, -*s2.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">if</span> (!s3.<span class="built_in">empty</span>()) mx = std::<span class="built_in">max</span>(mx, -*s3.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">if</span> (mx &lt; ans) &#123;</span><br><span class="line">      ans = mx, idx = u;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; idx &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ORZXKR</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\n&quot;;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P4248 [AHOI2013] 差异 题解</title>
    <url>/2023/07/22/P4248-AHOI2013-%E5%B7%AE%E5%BC%82-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求 $\displaystyle \sum_{1\leq ij\leq n}\text{len}(T_i)+\text{len}(T_j)-2\times\text{lcp}(T_i,T_j)$。</p>
<p>其中，$\text{len}(a)$ 表示字符串 $a$ 的长度，$\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。</p>
<p><a href="https://www.luogu.com.cn/problem/P4248">link</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑把 $S$ 的反串的 parent 树建出来。</p>
<p>设 $T_i$ 的 endpos 等价类是 $x$，$T_j$ 的 endpos 等价类是 $y$。</p>
<p>由于 parent 树上任意一个点的父亲一定是这个点的后缀，所以 $T_i$ 和 $T_j$ 的公共前缀一定就在反串 parent 树上 $x$ 和 $y$ 某个公共祖先所表示的等价类里，而最长的一定就在 $x$ 和 $y$ 的 LCA 上。</p>
<p>由于 $T_i,T_j$ 和 $\text{lcp}(T_i,T_j)$ 一定都是反串的前缀，所以他们的长度一定都是所在等价类最大的，那么 $\text{len}(T_i)+\text{len}(T_j)-2\times\text{lcp}(T_i,T_j)$ 就等于 $\text{len}_x+\text{len}<em>y-2\times \text{len}</em>{\text{lca}}$，如果把 parent 树的边权看作相邻两点 $\text{len}$ 的差值，那么原式就是 $x,y$ 的树上最短路径的长度。</p>
<p>然后对于每条边算贡献即可，即设 $\text{size}_x$ 表示 $x$ 的子树里反串前缀所在的等价类的个数，答案就是 $\displaystyle \sum\left(\text{size}_x\times(n-\text{size}_x)\times(\text{len}<em>x-\text{len}</em>{\text{fa}_x})\right)$。</p>
<p>时间复杂度：$O(n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int int64_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, tot = <span class="number">1</span>, lst = <span class="number">1</span>, nxt[kMaxN][<span class="number">26</span>], len[kMaxN], fa[kMaxN], sz[kMaxN];</span><br><span class="line">i64 ans;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cur = ++tot, p = lst;</span><br><span class="line">  lst = cur;</span><br><span class="line">  len[cur] = len[p] + <span class="number">1</span>, sz[cur] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; p &amp;&amp; !nxt[p][c]; p = fa[p]) nxt[p][c] = cur;</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    fa[cur] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> q = nxt[p][c];</span><br><span class="line">    <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) &#123;</span><br><span class="line">      fa[cur] = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> nw = ++tot;</span><br><span class="line">      fa[nw] = fa[q], len[nw] = len[p] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        nxt[nw][i] = nxt[q][i];</span><br><span class="line">      fa[q] = fa[cur] = nw;</span><br><span class="line">      <span class="keyword">for</span> (; p &amp;&amp; nxt[p][c] == q; p = fa[p]) nxt[p][c] = nw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    ans += (i64)sz[v] * (n - sz[v]) * (len[v] - len[u]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  n = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; ~i; --i)</span><br><span class="line">    <span class="built_in">ins</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i)</span><br><span class="line">    G[fa[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ORZXKR</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\n&quot;;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>字符串</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P9371 [APIO2023] 序列 题解</title>
    <url>/2023/06/26/P9371-APIO2023-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P9371">link</a></p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先考虑一个序列的中位数满足什么条件。</p>
<p>设中位数 $a$ 的个数是 $x$，小于中位数的个数是 $y$，大于中位数的个数是 $z$。</p>
<p>那么满足下面两个条件：$x+y\geq z,x+z\geq y$。</p>
<p>转化一下就是：$-x\leq z-y\leq x$。</p>
<p>考虑给区间里小于 $a$ 的数赋一个权值 $-1$，大于 $a$ 的赋 $1$，等于 $a$ 为 $0$。设 $sum_k$ 为权值的前缀和，$cnt_k$ 为这个前缀的 $a$ 的个数。</p>
<p>就是求满足 $cnt_{l-1}-cnt_r\leq sum_r-sum_{l-1}\leq cnt_r-cnt_{l-1}$ 的区间 $[l,r]$ 中最大的 $cnt_r-cnt_{l-1}$。</p>
<hr>
<p>考虑从小到大枚举 $a$，容易发现 $cnt$ 和 $sum$ 都可以用线段树维护，这里不再赘述。</p>
<p>把上面那个式子转化一下得：$sum_{l-1}+cnt_{l-1}\leq sum_r+cnt_r$ 且 $cnt_{l-1}-sum_{l-1}\leq cnt_r-sum_r$。</p>
<p>容易发现这是一个二维偏序的结构，所以把 $(sum_{x}+cnt_{x},cnt_{x}-sum_x)$ 看成一个点，就只要求一个二维偏序了。</p>
<p>暴力是 $O(n^2\log n)$。</p>
<hr>
<p>考虑优化。</p>
<p>观察一下这些点的走势会发现 $A_x&#x3D;a$ 时会向右上走，$A_x&lt;a$ 向左上，$A_x&gt;a$ 向右下。</p>
<p>于是可以画出样例 2 中 $a&#x3D;1$ 的图像：</p>
<p><a href="https://imgse.com/i/pCVv5Af"><img src="https://s1.ax1x.com/2023/06/11/pCVv5Af.png" alt="pCVv5Af.png"></a></p>
<p>会发现 $cnt$ 相同的点在同一条 $y&#x3D;-x+2\times cnt$ 的直线上，问题就转化为：给定若干条斜率为 $-1$ 的线段，求出所有线段 $l_1,l_2$，满足 $l_1$ 上存在点在 $l_2$ 的任一点的右上方的最大的 $l_1$ 与 $l_2$ 的距离。 </p>
<p>假设给定 $l_2$，那么 $l_1$ 就要满足与下面的阴影有交点：</p>
<p><a href="https://imgse.com/i/pCVxkuR"><img src="https://s1.ax1x.com/2023/06/11/pCVxkuR.png" alt="pCVxkuR.png"></a></p>
<p>写成式子就是：$maxx_1\geq minx_2,maxy_1\geq miny_2,cnt_1\geq cnt_2$。容易发现这个式子是充分必要的。</p>
<p>所以只要把每条斜率为 $-1$ 的线段的 $(minx,miny)$ 和 $(maxx,maxy)$ 求出来，跑二维偏序即可。</p>
<p>（树状数组维护 $cnt$ 的最小值，这里不用考虑 $cnt_1\geq cnt_2$ 的条件，因为 $cnt_1 &lt; cnt_2$ 时一定不是最优解。）</p>
<p>均摊下来就是 $O(n\log n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sequence.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> mxx, mxy, mix, miy;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> _mxx, <span class="type">int</span> _mxy, <span class="type">int</span> _mix, <span class="type">int</span> _miy) : <span class="built_in">mxx</span>(_mxx), <span class="built_in">mxy</span>(_mxy), <span class="built_in">mix</span>(_mix), <span class="built_in">miy</span>(_miy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LYX</span> &#123;</span><br><span class="line">  pii p;</span><br><span class="line">  <span class="type">int</span> op, id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LYX</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">LYX</span>(pii _p, <span class="type">int</span> _op, <span class="type">int</span> _id) : <span class="built_in">p</span>(_p), <span class="built_in">op</span>(_op), <span class="built_in">id</span>(_id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[kMaxN], mxx[kMaxN &lt;&lt; <span class="number">2</span>], mxy[kMaxN &lt;&lt; <span class="number">2</span>], mix[kMaxN &lt;&lt; <span class="number">2</span>], miy[kMaxN &lt;&lt; <span class="number">2</span>], tagx[kMaxN &lt;&lt; <span class="number">2</span>], tagy[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tr[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; pos[kMaxN];</span><br><span class="line">LYX pp[kMaxN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> LYX &amp;l1, <span class="type">const</span> LYX &amp;l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> l1.p.first &lt; l2.p.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">merge</span><span class="params">(Node ls, Node rs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Node</span>(std::<span class="built_in">max</span>(ls.mxx, rs.mxx), std::<span class="built_in">max</span>(ls.mxy, rs.mxy), std::<span class="built_in">min</span>(ls.mix, rs.mix), std::<span class="built_in">min</span>(ls.miy, rs.miy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  mxx[x] = std::<span class="built_in">max</span>(mxx[x &lt;&lt; <span class="number">1</span>], mxx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mix[x] = std::<span class="built_in">min</span>(mix[x &lt;&lt; <span class="number">1</span>], mix[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mxy[x] = std::<span class="built_in">max</span>(mxy[x &lt;&lt; <span class="number">1</span>], mxy[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  miy[x] = std::<span class="built_in">min</span>(miy[x &lt;&lt; <span class="number">1</span>], miy[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtagx</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  mxx[x] += v, mix[x] += v, tagx[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtagy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  mxy[x] += v, miy[x] += v, tagy[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tagx[x] &amp;&amp; !tagy[x]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (tagx[x]) <span class="built_in">addtagx</span>(x &lt;&lt; <span class="number">1</span>, tagx[x]), <span class="built_in">addtagx</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tagx[x]);</span><br><span class="line">  <span class="keyword">if</span> (tagy[x]) <span class="built_in">addtagy</span>(x &lt;&lt; <span class="number">1</span>, tagy[x]), <span class="built_in">addtagy</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tagy[x]);</span><br><span class="line">  tagx[x] = tagy[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> vx, <span class="type">int</span> vy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addtagx</span>(x, vx), <span class="built_in">addtagy</span>(x, vy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, vx, vy), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, vx, vy);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">-1e9</span>, <span class="number">-1e9</span>, <span class="number">1e9</span>, <span class="number">1e9</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(mxx[x], mxy[x], mix[x], miy[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  Node ls = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr), rs = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">merge</span>(ls, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= <span class="number">2e6</span>; x += x &amp; -x)</span><br><span class="line">    tr[x] = std::<span class="built_in">min</span>(tr[x], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">    ret = std::<span class="built_in">min</span>(ret, tr[x]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= <span class="number">2e6</span>; x += x &amp; -x)</span><br><span class="line">    tr[x] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> val = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, i, n, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(tr, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pos[i])</span><br><span class="line">      <span class="keyword">if</span> (x &amp;&amp; x &lt;= n) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, n, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(pos[i].<span class="built_in">size</span>()); ++j) &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n, pos[i][j], pos[i][j + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">      pp[++cnt] = <span class="built_in">LYX</span>(std::<span class="built_in">make_pair</span>(p.mix, p.miy), <span class="number">0</span>, j);</span><br><span class="line">      pp[++cnt] = <span class="built_in">LYX</span>(std::<span class="built_in">make_pair</span>(p.mxx, p.mxy), <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(pp + <span class="number">1</span>, pp + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, k; j &lt;= cnt; j = k) &#123;</span><br><span class="line">      now = j;</span><br><span class="line">      <span class="keyword">for</span> (k = j; k &lt;= cnt &amp;&amp; pp[k].p.first == pp[j].p.first; ++k)</span><br><span class="line">        <span class="keyword">if</span> (pp[k].op == <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">upd</span>(pp[k].p.second + <span class="number">1e6</span>, pp[k].id);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; k; ++s)</span><br><span class="line">        <span class="keyword">if</span> (pp[s].op == <span class="number">1</span>)</span><br><span class="line">          ret = std::<span class="built_in">max</span>(ret, pp[s].id - <span class="built_in">qry</span>(pp[s].p.second + <span class="number">1e6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; now; ++k)</span><br><span class="line">      <span class="built_in">clr</span>(pp[k].p.second + <span class="number">1e6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pos[i])</span><br><span class="line">      <span class="keyword">if</span> (x &amp;&amp; x &lt;= n) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, n, <span class="number">-2</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sequence</span><span class="params">(<span class="type">int</span> N, std::vector&lt;<span class="type">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">  n = N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i + <span class="number">1</span>] = A[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[i].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[a[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[i].<span class="built_in">emplace_back</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>APIO</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线学习笔记</title>
    <url>/2023/06/28/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>其实很久以前就自己看过扫描线，但是由于水平不够+没搞懂的不去搞所以也就今天才真正弄明白了。</p>
<span id="more"></span>

<h2 id="Part-1-算法用途"><a href="#Part-1-算法用途" class="headerlink" title="Part 1 算法用途"></a>Part 1 算法用途</h2><p>解决在坐标轴上一些与图形有关的问题，包括一堆矩形并的面积、周长等等。</p>
<h2 id="Part-2-算法思想"><a href="#Part-2-算法思想" class="headerlink" title="Part 2 算法思想"></a>Part 2 算法思想</h2><p>顾名思义，就是用一条线在坐标轴上扫来扫去。</p>
<p>以求矩形并的面积为例：</p>
<p>现在有 $n$ 个矩形，矩形的四个点的 $x$ 和 $y$ 坐标都 $\in [0,10^9]$ 且为整点，问这些矩形并起来的面积（$n\leq 10^5$）。</p>
<hr>
<p>有一个思路就是对于每个矩形暴力打标记，然后看被标记的点数，时间复杂度：$O(V^2)$。</p>
<p>这样做显然是会爆炸的而且坐标还必须是整数。</p>
<p>考虑优化。</p>
<hr>
<p>注意到值域是远大于 $n$ 的，所以可以把矩形四个点的 $x$ 和 $y$ 离散化下来，这样整个坐标轴就被这些离散化下来的横线和竖线给分割成很多个网格，每个网格里的点是否被标记的状态显然是相同的，所以可以像上面那样暴力打标记，时间复杂度：$O(n^2)$。</p>
<p>像这样：</p>
<p><img src="https://s1.ax1x.com/2023/06/28/pCwnt5q.png"></p>
<p>就直接求每个标蓝网格的面积即可</p>
<hr>
<p>其实算法可以做得更优，设一个矩形为 $(x_1,y_1)-(x_2,y_2)$，类似于差分，可以把它拆成入边和出边。</p>
<p>入边表示在 $x_1$ 把 $[y_1,y_2]$ 的覆盖层数 $+1$，出边表示在 $x_2$ 把 $[y_1,y_2]$ 覆盖层数 $-1$，然后依次扫描离散化出来的线，最后被需要计入总答案的就是当前覆盖层数 $\geq 1$ 的线段总长度 $\times$ 当前两条相邻的线截出的长度，直接数据结构维护可以做到 $O(n\log n)$（详细维护方法见例题）。</p>
<hr>
<p>上面就是扫描线的流程，也就是把直线离散化然后对于被两条相邻的线截开的区域用数据结构维护。</p>
<h2 id="Part-3-例题"><a href="#Part-3-例题" class="headerlink" title="Part 3 例题"></a>Part 3 例题</h2><h3 id="P5490-【模板】扫描线"><a href="#P5490-【模板】扫描线" class="headerlink" title="P5490 【模板】扫描线"></a><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></h3><p>就是上面的模板，然后用线段树维护。</p>
<p>由于要维护当前覆盖层数 $\geq 1$ 的点的个数，考虑记录区间 $\min$ 值、区间 $\min$ 值出现的线段的长度和区间不为 $0$ 的所有线段的长度。</p>
<p>这个显然是可以维护的，前两个直接搞。后面的那个如果区间 $\min$ 值为 $0$，答案就是区间总长度 $-$ 区间 $\min$ 值的线段长度。</p>
<p>如果区间 $\min$ 值不为 $0$，答案就是区间总长度。</p>
<p>时间复杂度：$O(n\log n)$。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> x1[kMaxN], y1[kMaxN], x2[kMaxN], y2[kMaxN], b[kMaxN], lsh[kMaxN];</span><br><span class="line"><span class="type">int</span> sum[kMaxN &lt;&lt; <span class="number">2</span>], mini[kMaxN &lt;&lt; <span class="number">2</span>], cnt[kMaxN &lt;&lt; <span class="number">2</span>], tag[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; v[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m), std::<span class="built_in">sort</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k);</span><br><span class="line">  m = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m) - (b + <span class="number">1</span>);</span><br><span class="line">  k = std::<span class="built_in">unique</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k) - (lsh + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    y1[i] = std::<span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k, y1[i]) - lsh;</span><br><span class="line">    y2[i] = std::<span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k, y2[i]) - lsh;</span><br><span class="line">    v[std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, x1[i]) - b].<span class="built_in">emplace_back</span>(y1[i], y2[i], <span class="number">1</span>);</span><br><span class="line">    v[std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, x2[i]) - b].<span class="built_in">emplace_back</span>(y1[i], y2[i], <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  sum[x] = sum[x &lt;&lt; <span class="number">1</span>] + sum[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (mini[x &lt;&lt; <span class="number">1</span>] &lt; mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mini[x &lt;&lt; <span class="number">1</span>] &gt; mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span>] + cnt[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  tag[x] += v, mini[x] += v;</span><br><span class="line">  <span class="keyword">if</span> (mini[x]) sum[x] = lsh[r + <span class="number">1</span>] - lsh[l];</span><br><span class="line">  <span class="keyword">else</span> sum[x] = lsh[r + <span class="number">1</span>] - lsh[l] - cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span>, l, mid, tag[x]), <span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">  tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    cnt[x] = lsh[r + <span class="number">1</span>] - lsh[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addtag</span>(x, l, r, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, v), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, v);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; x1[i] &gt;&gt; y1[i] &gt;&gt; x2[i] &gt;&gt; y2[i];</span><br><span class="line">    b[++m] = x1[i]; b[++m] = x2[i];</span><br><span class="line">    lsh[++k] = y1[i]; lsh[++k] = y2[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">discrete</span>();</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : v[i]) &#123;</span><br><span class="line">      <span class="type">int</span> l = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(p), r = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(p), c = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(p);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, k - <span class="number">1</span>, l, r - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="number">1ll</span> * (b[i + <span class="number">1</span>] - b[i]) * sum[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &#x27;s&#x27; &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…….</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>学习笔记</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
</search>
