<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>P9371 [APIO2023] 序列 题解</title>
    <url>/2023/06/26/P9371-APIO2023-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P9371">link</a></p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先考虑一个序列的中位数满足什么条件。</p>
<p>设中位数 $a$ 的个数是 $x$，小于中位数的个数是 $y$，大于中位数的个数是 $z$。</p>
<p>那么满足下面两个条件：$x+y\geq z,x+z\geq y$。</p>
<p>转化一下就是：$-x\leq z-y\leq x$。</p>
<p>考虑给区间里小于 $a$ 的数赋一个权值 $-1$，大于 $a$ 的赋 $1$，等于 $a$ 为 $0$。设 $sum_k$ 为权值的前缀和，$cnt_k$ 为这个前缀的 $a$ 的个数。</p>
<p>就是求满足 $cnt_{l-1}-cnt_r\leq sum_r-sum_{l-1}\leq cnt_r-cnt_{l-1}$ 的区间 $[l,r]$ 中最大的 $cnt_r-cnt_{l-1}$。</p>
<hr>
<p>考虑从小到大枚举 $a$，容易发现 $cnt$ 和 $sum$ 都可以用线段树维护，这里不再赘述。</p>
<p>把上面那个式子转化一下得：$sum_{l-1}+cnt_{l-1}\leq sum_r+cnt_r$ 且 $cnt_{l-1}-sum_{l-1}\leq cnt_r-sum_r$。</p>
<p>容易发现这是一个二维偏序的结构，所以把 $(sum_{x}+cnt_{x},cnt_{x}-sum_x)$ 看成一个点，就只要求一个二维偏序了。</p>
<p>暴力是 $O(n^2\log n)$。</p>
<hr>
<p>考虑优化。</p>
<p>观察一下这些点的走势会发现 $A_x&#x3D;a$ 时会向右上走，$A_x&lt;a$ 向左上，$A_x&gt;a$ 向右下。</p>
<p>于是可以画出样例 2 中 $a&#x3D;1$ 的图像：</p>
<p><a href="https://imgse.com/i/pCVv5Af"><img src="https://s1.ax1x.com/2023/06/11/pCVv5Af.png" alt="pCVv5Af.png"></a></p>
<p>会发现 $cnt$ 相同的点在同一条 $y&#x3D;-x+2\times cnt$ 的直线上，问题就转化为：给定若干条斜率为 $-1$ 的线段，求出所有线段 $l_1,l_2$，满足 $l_1$ 上存在点在 $l_2$ 的任一点的右上方的最大的 $l_1$ 与 $l_2$ 的距离。 </p>
<p>假设给定 $l_2$，那么 $l_1$ 就要满足与下面的阴影有交点：</p>
<p><a href="https://imgse.com/i/pCVxkuR"><img src="https://s1.ax1x.com/2023/06/11/pCVxkuR.png" alt="pCVxkuR.png"></a></p>
<p>写成式子就是：$maxx_1\geq minx_2,maxy_1\geq miny_2,cnt_1\geq cnt_2$。容易发现这个式子是充分必要的。</p>
<p>所以只要把每条斜率为 $-1$ 的线段的 $(minx,miny)$ 和 $(maxx,maxy)$ 求出来，跑二维偏序即可。</p>
<p>（树状数组维护 $cnt$ 的最小值，这里不用考虑 $cnt_1\geq cnt_2$ 的条件，因为 $cnt_1 &lt; cnt_2$ 时一定不是最优解。）</p>
<p>均摊下来就是 $O(n\log n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sequence.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> mxx, mxy, mix, miy;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> _mxx, <span class="type">int</span> _mxy, <span class="type">int</span> _mix, <span class="type">int</span> _miy) : <span class="built_in">mxx</span>(_mxx), <span class="built_in">mxy</span>(_mxy), <span class="built_in">mix</span>(_mix), <span class="built_in">miy</span>(_miy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LYX</span> &#123;</span><br><span class="line">  pii p;</span><br><span class="line">  <span class="type">int</span> op, id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LYX</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">LYX</span>(pii _p, <span class="type">int</span> _op, <span class="type">int</span> _id) : <span class="built_in">p</span>(_p), <span class="built_in">op</span>(_op), <span class="built_in">id</span>(_id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[kMaxN], mxx[kMaxN &lt;&lt; <span class="number">2</span>], mxy[kMaxN &lt;&lt; <span class="number">2</span>], mix[kMaxN &lt;&lt; <span class="number">2</span>], miy[kMaxN &lt;&lt; <span class="number">2</span>], tagx[kMaxN &lt;&lt; <span class="number">2</span>], tagy[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tr[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; pos[kMaxN];</span><br><span class="line">LYX pp[kMaxN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> LYX &amp;l1, <span class="type">const</span> LYX &amp;l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> l1.p.first &lt; l2.p.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">merge</span><span class="params">(Node ls, Node rs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Node</span>(std::<span class="built_in">max</span>(ls.mxx, rs.mxx), std::<span class="built_in">max</span>(ls.mxy, rs.mxy), std::<span class="built_in">min</span>(ls.mix, rs.mix), std::<span class="built_in">min</span>(ls.miy, rs.miy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  mxx[x] = std::<span class="built_in">max</span>(mxx[x &lt;&lt; <span class="number">1</span>], mxx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mix[x] = std::<span class="built_in">min</span>(mix[x &lt;&lt; <span class="number">1</span>], mix[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mxy[x] = std::<span class="built_in">max</span>(mxy[x &lt;&lt; <span class="number">1</span>], mxy[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  miy[x] = std::<span class="built_in">min</span>(miy[x &lt;&lt; <span class="number">1</span>], miy[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtagx</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  mxx[x] += v, mix[x] += v, tagx[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtagy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  mxy[x] += v, miy[x] += v, tagy[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tagx[x] &amp;&amp; !tagy[x]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (tagx[x]) <span class="built_in">addtagx</span>(x &lt;&lt; <span class="number">1</span>, tagx[x]), <span class="built_in">addtagx</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tagx[x]);</span><br><span class="line">  <span class="keyword">if</span> (tagy[x]) <span class="built_in">addtagy</span>(x &lt;&lt; <span class="number">1</span>, tagy[x]), <span class="built_in">addtagy</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tagy[x]);</span><br><span class="line">  tagx[x] = tagy[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> vx, <span class="type">int</span> vy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addtagx</span>(x, vx), <span class="built_in">addtagy</span>(x, vy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, vx, vy), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, vx, vy);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">-1e9</span>, <span class="number">-1e9</span>, <span class="number">1e9</span>, <span class="number">1e9</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(mxx[x], mxy[x], mix[x], miy[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  Node ls = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr), rs = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">merge</span>(ls, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= <span class="number">2e6</span>; x += x &amp; -x)</span><br><span class="line">    tr[x] = std::<span class="built_in">min</span>(tr[x], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">    ret = std::<span class="built_in">min</span>(ret, tr[x]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= <span class="number">2e6</span>; x += x &amp; -x)</span><br><span class="line">    tr[x] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> val = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, i, n, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(tr, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pos[i])</span><br><span class="line">      <span class="keyword">if</span> (x &amp;&amp; x &lt;= n) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, n, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(pos[i].<span class="built_in">size</span>()); ++j) &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n, pos[i][j], pos[i][j + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">      pp[++cnt] = <span class="built_in">LYX</span>(std::<span class="built_in">make_pair</span>(p.mix, p.miy), <span class="number">0</span>, j);</span><br><span class="line">      pp[++cnt] = <span class="built_in">LYX</span>(std::<span class="built_in">make_pair</span>(p.mxx, p.mxy), <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(pp + <span class="number">1</span>, pp + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, k; j &lt;= cnt; j = k) &#123;</span><br><span class="line">      now = j;</span><br><span class="line">      <span class="keyword">for</span> (k = j; k &lt;= cnt &amp;&amp; pp[k].p.first == pp[j].p.first; ++k)</span><br><span class="line">        <span class="keyword">if</span> (pp[k].op == <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">upd</span>(pp[k].p.second + <span class="number">1e6</span>, pp[k].id);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; k; ++s)</span><br><span class="line">        <span class="keyword">if</span> (pp[s].op == <span class="number">1</span>)</span><br><span class="line">          ret = std::<span class="built_in">max</span>(ret, pp[s].id - <span class="built_in">qry</span>(pp[s].p.second + <span class="number">1e6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; now; ++k)</span><br><span class="line">      <span class="built_in">clr</span>(pp[k].p.second + <span class="number">1e6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pos[i])</span><br><span class="line">      <span class="keyword">if</span> (x &amp;&amp; x &lt;= n) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, n, <span class="number">-2</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sequence</span><span class="params">(<span class="type">int</span> N, std::vector&lt;<span class="type">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">  n = N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i + <span class="number">1</span>] = A[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[i].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[a[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    pos[i].<span class="built_in">emplace_back</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>CF1804D Accommodation 题解</title>
    <url>/2023/06/27/CF1804D-Accommodation-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/CF1804D">link</a></p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于行与行之间独立，所以可以对每行分别求最大和最小值。</p>
<p>先考虑最小值。</p>
<p>先找出每段 $1$ 的长度，显然是尽量往里面放双人房，如果所需双人房个数 $&gt;\dfrac{m}{4}$，那么就删掉一些双人房然后塞单人房即可。</p>
<p>然后是最大值。</p>
<p>设 $1$ 的个数为 $c$，那么答案就是 $c$ 减双人房中两个都是 $1$ 的房间个数。</p>
<p>考虑双人房中两个都是 $1$ 的最小房间个数怎么求，由于这个又等于 $\dfrac{m}{4}$ 减双人房中有至少一个为 $0$ 房间个数。</p>
<p>至少一个为 $0$ 的个数就从前往后扫，如果发现 $a_i+a_{i+1}&lt;2$ 就用双人房，然后跳到 $i+2$ 继续搞。</p>
<p>这样做显然是对的，证明如下：</p>
<p>考虑把 $0$ 和他们两边的 $1$ 的区间最边上的 $1$ 合并成一个大区间 $[l_i,r_i]$，如果两个 $0$ 区间中间只隔了 $1$ 个 $1$ 那么把他们也合并了。</p>
<p>容易发现区间不会相交。上面那个操作就是在每个区间里找最多不相交的二连线段个数，显然从前往后扫是最优的。</p>
<p>至少一个为 $0$ 的个数如果大于 $\dfrac{m}{4}$ 就取到 $\dfrac{m}{4}$。</p>
<p>时间复杂度：$O(nm)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[kMaxN], b[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt2 = m / <span class="number">4</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> lst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]) ++lst;</span><br><span class="line">    <span class="keyword">if</span> (!a[i + <span class="number">1</span>] &amp;&amp; lst) &#123;</span><br><span class="line">      b[++k] = lst, lst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    sum += b[i] / <span class="number">2</span>;</span><br><span class="line">    tot += b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum &lt;= cnt2) <span class="keyword">return</span> sum + tot - <span class="number">2</span> * sum;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> cnt2 + tot - <span class="number">2</span> * cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt2 = m / <span class="number">4</span>, k = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ret += a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i] || !a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      ++k, i += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret - (cnt2 - std::<span class="built_in">min</span>(cnt2, k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mi = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    mi += <span class="built_in">getmin</span>(s), mx += <span class="built_in">getmax</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; mi &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ORZXKR</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &#x27;s&#x27; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>扫描线学习笔记</title>
    <url>/2023/06/28/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>其实很久以前就自己看过扫描线，但是由于水平不够+没搞懂的不去搞所以也就今天才真正弄明白了。</p>
<span id="more"></span>

<h2 id="Part-1-算法用途"><a href="#Part-1-算法用途" class="headerlink" title="Part 1 算法用途"></a>Part 1 算法用途</h2><p>解决在坐标轴上一些与图形有关的问题，包括一堆矩形并的面积、周长等等。</p>
<h2 id="Part-2-算法思想"><a href="#Part-2-算法思想" class="headerlink" title="Part 2 算法思想"></a>Part 2 算法思想</h2><p>顾名思义，就是用一条线在坐标轴上扫来扫去。</p>
<p>以求矩形并的面积为例：</p>
<p>现在有 $n$ 个矩形，矩形的四个点的 $x$ 和 $y$ 坐标都 $\in [0,10^9]$ 且为整点，问这些矩形并起来的面积（$n\leq 10^5$）。</p>
<hr>
<p>有一个思路就是对于每个矩形暴力打标记，然后看被标记的点数，时间复杂度：$O(V^2)$。</p>
<p>这样做显然是会爆炸的而且坐标还必须是整数。</p>
<p>考虑优化。</p>
<hr>
<p>注意到值域是远大于 $n$ 的，所以可以把矩形四个点的 $x$ 和 $y$ 离散化下来，这样整个坐标轴就被这些离散化下来的横线和竖线给分割成很多个网格，每个网格里的点是否被标记的状态显然是相同的，所以可以像上面那样暴力打标记，时间复杂度：$O(n^2)$。</p>
<p>像这样：</p>
<p><img src="https://s1.ax1x.com/2023/06/28/pCwnt5q.png"></p>
<p>就直接求每个标蓝网格的面积即可</p>
<hr>
<p>其实算法可以做得更优，设一个矩形为 $(x_1,y_1)-(x_2,y_2)$，类似于差分，可以把它拆成入边和出边。</p>
<p>入边表示在 $x_1$ 把 $[y_1,y_2]$ 的覆盖层数 $+1$，出边表示在 $x_2$ 把 $[y_1,y_2]$ 覆盖层数 $-1$，然后依次扫描离散化出来的线，最后被需要计入总答案的就是当前覆盖层数 $\geq 1$ 的线段总长度 $\times$ 当前两条相邻的线截出的长度，直接数据结构维护可以做到 $O(n\log n)$（详细维护方法见例题）。</p>
<hr>
<p>上面就是扫描线的流程，也就是把直线离散化然后对于被两条相邻的线截开的区域用数据结构维护。</p>
<h2 id="Part-3-例题"><a href="#Part-3-例题" class="headerlink" title="Part 3 例题"></a>Part 3 例题</h2><h3 id="1-P5490-【模板】扫描线"><a href="#1-P5490-【模板】扫描线" class="headerlink" title="1. P5490 【模板】扫描线"></a>1. <a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></h3><p>就是上面的模板，然后用线段树维护。</p>
<p>由于要维护当前覆盖层数 $\geq 1$ 的点的个数，考虑记录区间 $\min$ 值、区间 $\min$ 值出现的线段的长度和区间不为 $0$ 的所有线段的长度。</p>
<p>这个显然是可以维护的，前两个直接搞。后面的那个如果区间 $\min$ 值为 $0$，答案就是区间总长度 $-$ 区间 $\min$ 值的线段长度。</p>
<p>如果区间 $\min$ 值不为 $0$，答案就是区间总长度。</p>
<p>时间复杂度：$O(n\log n)$。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> x1[kMaxN], y1[kMaxN], x2[kMaxN], y2[kMaxN], b[kMaxN], lsh[kMaxN];</span><br><span class="line"><span class="type">int</span> sum[kMaxN &lt;&lt; <span class="number">2</span>], mini[kMaxN &lt;&lt; <span class="number">2</span>], cnt[kMaxN &lt;&lt; <span class="number">2</span>], tag[kMaxN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; v[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m), std::<span class="built_in">sort</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k);</span><br><span class="line">  m = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m) - (b + <span class="number">1</span>);</span><br><span class="line">  k = std::<span class="built_in">unique</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k) - (lsh + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    y1[i] = std::<span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k, y1[i]) - lsh;</span><br><span class="line">    y2[i] = std::<span class="built_in">lower_bound</span>(lsh + <span class="number">1</span>, lsh + <span class="number">1</span> + k, y2[i]) - lsh;</span><br><span class="line">    v[std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, x1[i]) - b].<span class="built_in">emplace_back</span>(y1[i], y2[i], <span class="number">1</span>);</span><br><span class="line">    v[std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, x2[i]) - b].<span class="built_in">emplace_back</span>(y1[i], y2[i], <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  sum[x] = sum[x &lt;&lt; <span class="number">1</span>] + sum[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (mini[x &lt;&lt; <span class="number">1</span>] &lt; mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mini[x &lt;&lt; <span class="number">1</span>] &gt; mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mini[x] = mini[x &lt;&lt; <span class="number">1</span>], cnt[x] = cnt[x &lt;&lt; <span class="number">1</span>] + cnt[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  tag[x] += v, mini[x] += v;</span><br><span class="line">  <span class="keyword">if</span> (mini[x]) sum[x] = lsh[r + <span class="number">1</span>] - lsh[l];</span><br><span class="line">  <span class="keyword">else</span> sum[x] = lsh[r + <span class="number">1</span>] - lsh[l] - cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span>, l, mid, tag[x]), <span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">  tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    cnt[x] = lsh[r + <span class="number">1</span>] - lsh[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addtag</span>(x, l, r, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, v), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, v);</span><br><span class="line">  <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dickdreamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; x1[i] &gt;&gt; y1[i] &gt;&gt; x2[i] &gt;&gt; y2[i];</span><br><span class="line">    b[++m] = x1[i]; b[++m] = x2[i];</span><br><span class="line">    lsh[++k] = y1[i]; lsh[++k] = y2[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">discrete</span>();</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : v[i]) &#123;</span><br><span class="line">      <span class="type">int</span> l = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(p), r = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(p), c = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(p);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, k - <span class="number">1</span>, l, r - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="number">1ll</span> * (b[i + <span class="number">1</span>] - b[i]) * sum[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>), std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">dickdreamer</span>();</span><br><span class="line">  <span class="comment">// std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &#x27;s&#x27; &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…….</p>
]]></content>
  </entry>
</search>
