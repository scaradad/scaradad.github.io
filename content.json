{"posts":[{"title":"CF1804D Accommodation 题解","text":"Description link Solution 由于行与行之间独立，所以可以对每行分别求最大和最小值。 先考虑最小值。 先找出每段 \\(1\\) 的长度，显然是尽量往里面放双人房，如果所需双人房个数 \\(&gt;\\dfrac{m}{4}\\)，那么就删掉一些双人房然后塞单人房即可。 然后是最大值。 设 \\(1\\) 的个数为 \\(c\\)，那么答案就是 \\(c\\) 减双人房中两个都是 \\(1\\) 的房间个数。 考虑双人房中两个都是 \\(1\\) 的最小房间个数怎么求，由于这个又等于 \\(\\dfrac{m}{4}\\) 减双人房中有至少一个为 \\(0\\) 房间个数。 至少一个为 \\(0\\) 的个数就从前往后扫，如果发现 \\(a_i+a_{i+1}&lt;2\\) 就用双人房，然后跳到 \\(i+2\\) 继续搞。 这样做显然是对的，证明如下： 考虑把 \\(0\\) 和他们两边的 \\(1\\) 的区间最边上的 \\(1\\) 合并成一个大区间 \\([l_i,r_i]\\)，如果两个 \\(0\\) 区间中间只隔了 \\(1\\) 个 \\(1\\) 那么把他们也合并了。 容易发现区间不会相交。上面那个操作就是在每个区间里找最多不相交的二连线段个数，显然从前往后扫是最优的。 至少一个为 \\(0\\) 的个数如果大于 \\(\\dfrac{m}{4}\\) 就取到 \\(\\dfrac{m}{4}\\)。 时间复杂度：\\(O(nm)\\)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;iostream&gt;// #define int long longconst int kMaxN = 5e5 + 5;int n, m;int a[kMaxN], b[kMaxN];int getmin(std::string s) { int cnt2 = m / 4, k = 0; for (int i = 1; i &lt;= m; ++i) a[i] = s[i] - '0'; int lst = 0; for (int i = 1; i &lt;= m; ++i) { if (a[i]) ++lst; if (!a[i + 1] &amp;&amp; lst) { b[++k] = lst, lst = 0; } } int sum = 0, tot = 0; for (int i = 1; i &lt;= k; ++i) { sum += b[i] / 2; tot += b[i]; } if (sum &lt;= cnt2) return sum + tot - 2 * sum; else return cnt2 + tot - 2 * cnt2;}int getmax(std::string s) { int cnt2 = m / 4, k = 0, ret = 0; for (int i = 1; i &lt;= m; ++i) { a[i] = s[i] - '0'; ret += a[i]; } for (int i = 1; i &lt; m;) { if (!a[i] || !a[i + 1]) { ++k, i += 2; } else { ++i; } } return ret - (cnt2 - std::min(cnt2, k));}void dickdreamer() { int mi = 0, mx = 0; std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { std::string s; std::cin &gt;&gt; s; s = &quot; &quot; + s; mi += getmin(s), mx += getmax(s); } std::cout &lt;&lt; mi &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; std::endl; return 0;}","link":"/2023/06/27/CF1804D-Accommodation-%E9%A2%98%E8%A7%A3/"},{"title":"CF932E Team Work 题解","text":"Description 给定 \\(n,k\\)，求： \\[\\displaystyle\\sum_{i=1}^{n}{\\binom{n}{i}\\times i^k}\\] \\(1\\leq k\\leq 5000,1\\leq n\\leq 10^9\\)。 Solution 看到那个 \\(i^k\\) 很不爽，但是 \\(k\\) 很小，考虑用斯特林数改写一下： \\[i^k=\\sum_{j=0}^{k}{\\binom{i}{j}\\left \\{ \\begin{matrix} k\\\\ j \\end{matrix} \\right \\}\\cdot j!}\\] 代回原式得： \\[\\displaystyle \\begin{aligned} &amp;\\sum_{i=0}^{n}{\\binom{n}{i}\\cdot\\sum_{j=0}^{k}{\\binom{i}{j}\\left \\{ {\\begin{matrix} k\\\\ j \\end{matrix}} \\right \\} j!} }\\\\ =&amp;\\sum_{j=0}^{k}{j!\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=0}^{n}{\\binom{n}{i}\\binom{i}{j}}}\\\\ =&amp;\\sum_{j=0}^{k}{j!\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=j}^{n}{\\frac{n!}{i!(n-i)!}\\cdot \\frac{i!}{j!(i-j)!}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=j}^{n}{\\frac{\\binom{n-j}{i-j}}{(n-j)!}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\frac{1}{(n-j)!}\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\sum_{i=0}^{n-j}{\\binom{n-j}{i}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\frac{2^{n-j}}{(n-j)!}\\cdot \\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}}\\\\ \\end{aligned}\\] 于是直接预处理出斯特林数即可做到 \\(O(k^2+k\\log n)\\)，如果用卷积预处理的话就可以做到 \\(O(k\\log k+k\\log n)\\)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;// #define int int64_tusing i64 = int64_t;const int kMod = 1e9 + 7;int s[5005][5005];int qpow(int bs, int idx = kMod - 2) { int ret = 1; for (; idx; idx &gt;&gt;= 1, bs = (i64)bs * bs % kMod) if (idx &amp; 1) ret = (i64)ret * bs % kMod; return ret;}void dickdreamer() { int n, k, ans = 0; std::cin &gt;&gt; n &gt;&gt; k; s[0][0] = 1; for (int i = 1; i &lt;= k; ++i) { for (int j = 1; j &lt;= i; ++j) { s[i][j] = (s[i - 1][j - 1] + (i64)j * s[i - 1][j] % kMod) % kMod; } } for (int i = 0, c = 1; i &lt;= std::min(n, k); ++i) { ans = (ans + (i64)s[k][i] * c % kMod * qpow(2, n - i) % kMod) % kMod; c = (i64)c * (n - i) % kMod; } std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/08/16/CF932E-Team-Work-%E9%A2%98%E8%A7%A3/"},{"title":"P3573 [POI2014] RAJ-Rally 题解","text":"Description 给定一个 \\(n\\) 个点 \\(m\\) 条边的有向无环图，每条边长度都是 \\(1\\)。 请找到一个点，使得删掉这个点后剩余的图中的最长路径最短。 \\(n\\leq 5\\times 10^5,m\\leq 10^6\\)。 Solution 设 \\(f_i\\) 表示以 \\(i\\) 为终点的最长路，\\(g_i\\) 表示以 \\(i\\) 为起点的最长路，\\(d_i\\) 为 \\(i\\) 的拓扑序。 这两个显然可以通过拓扑排序求出。 易知原图中的任何一个路径上的点的拓扑序一定是递增的，所以删掉一个点 \\(u\\)，剩余的路径只有 \\(f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)\\) 三种可能。 那么就可以维护三个 multiset，分别维护 \\(f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)\\)。 前两个直接在从小到大枚举 \\(d_u\\) 的时候增删，第三个可以每次先加入 \\(d_i=d_u-1\\) 的所有边，然后删去 \\(d_j=d_u\\) 的所有边，这样可以保证 \\(d_i&lt;d_u\\) 且 \\(d_j&gt;d_u\\)。 时间复杂度：\\(O((n+m)\\log (n+m))\\)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;// #define int int64_tconst int kMaxN = 5e5 + 5;int n, m, cnt;int id[kMaxN], deg[kMaxN], f[kMaxN], g[kMaxN];std::vector&lt;int&gt; G[kMaxN], rG[kMaxN];std::multiset&lt;int&gt; s1, s2, s3;// s1 : f[u]// s2 : g[u]// s3 : f[u] + g[v] + 1(u &lt; i &lt; v)void topo() { std::queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { if (!deg[i]) { q.emplace(i), f[i] = 0; } } while (!q.empty()) { int u = q.front(); q.pop(); id[++cnt] = u; for (auto v : G[u]) { f[v] = std::max(f[v], f[u] + 1); if (!--deg[v]) q.emplace(v); } }}void dickdreamer() { std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v), rG[v].emplace_back(u); ++deg[v]; } topo(); for (int i = n; i; --i) { int u = id[i]; for (auto v : G[u]) g[u] = std::max(g[u], g[v] + 1); } for (int i = 1; i &lt;= n; ++i) s2.emplace(-g[i]); int ans = 1e9, idx = 1; for (int i = 1; i &lt;= n; ++i) { int u = id[i]; if (i) { for (auto v : G[id[i - 1]]) s3.emplace(-(f[id[i - 1]] + g[v] + 1)); } for (auto v : rG[u]) { s3.erase(s3.lower_bound(-(f[v] + g[u] + 1))); } if (i) s1.emplace(-f[id[i - 1]]); s2.erase(s2.lower_bound(-g[u])); int mx = 0; if (!s1.empty()) mx = std::max(mx, -*s1.begin()); if (!s2.empty()) mx = std::max(mx, -*s2.begin()); if (!s3.empty()) mx = std::max(mx, -*s3.begin()); if (mx &lt; ans) { ans = mx, idx = u; } } std::cout &lt;&lt; idx &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/07/07/P3573-POI2014-RAJ-Rally-%E9%A2%98%E8%A7%A3/"},{"title":"P4248 [AHOI2013] 差异 题解","text":"Description 给定一个长度为 \\(n\\) 的字符串 \\(S\\)，令 \\(T_i\\) 表示它从第 \\(i\\) 个字符开始的后缀。求 \\(\\displaystyle \\sum_{1\\leq ij\\leq n}\\text{len}(T_i)+\\text{len}(T_j)-2\\times\\text{lcp}(T_i,T_j)\\)。 其中，\\(\\text{len}(a)\\) 表示字符串 \\(a\\) 的长度，\\(\\text{lcp}(a,b)\\) 表示字符串 \\(a\\) 和字符串 \\(b\\) 的最长公共前缀。 link Solution 考虑把 \\(S\\) 的反串的 parent 树建出来。 设 \\(T_i\\) 的 endpos 等价类是 \\(x\\)，\\(T_j\\) 的 endpos 等价类是 \\(y\\)。 由于 parent 树上任意一个点的父亲一定是这个点的后缀，所以 \\(T_i\\) 和 \\(T_j\\) 的公共前缀一定就在反串 parent 树上 \\(x\\) 和 \\(y\\) 某个公共祖先所表示的等价类里，而最长的一定就在 \\(x\\) 和 \\(y\\) 的 LCA 上。 由于 \\(T_i,T_j\\) 和 \\(\\text{lcp}(T_i,T_j)\\) 一定都是反串的前缀，所以他们的长度一定都是所在等价类最大的，那么 \\(\\text{len}(T_i)+\\text{len}(T_j)-2\\times\\text{lcp}(T_i,T_j)\\) 就等于 \\(\\text{len}_x+\\text{len}_y-2\\times \\text{len}_\\text{lca}\\)，如果把 parent 树的边权看作相邻两点 \\(\\text{len}\\) 的差值，那么原式就是 \\(x,y\\) 的树上最短路径的长度。 然后对于每条边算贡献即可，即设 \\(\\text{size}_x\\) 表示 \\(x\\) 的子树里反串前缀所在的等价类的个数，答案就是 \\(\\displaystyle\\sum\\left(\\text{size}_x\\times(n-\\text{size}_x)\\times(\\text{len}_x-\\text{len}_\\text{fa})\\right)\\)。 时间复杂度：\\(O(n)\\)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// #define int int64_tconst int kMaxN = 1e6 + 5;using i64 = int64_t;int n, tot = 1, lst = 1, nxt[kMaxN][26], len[kMaxN], fa[kMaxN], sz[kMaxN];i64 ans;std::vector&lt;int&gt; G[kMaxN];void ins(int c) { int cur = ++tot, p = lst; lst = cur; len[cur] = len[p] + 1, sz[cur] = 1; for (; p &amp;&amp; !nxt[p][c]; p = fa[p]) nxt[p][c] = cur; if (!p) { fa[cur] = 1; } else { int q = nxt[p][c]; if (len[q] == len[p] + 1) { fa[cur] = q; } else { int nw = ++tot; fa[nw] = fa[q], len[nw] = len[p] + 1; for (int i = 0; i &lt; 26; ++i) nxt[nw][i] = nxt[q][i]; fa[q] = fa[cur] = nw; for (; p &amp;&amp; nxt[p][c] == q; p = fa[p]) nxt[p][c] = nw; } }}void dfs(int u) { for (auto v : G[u]) { dfs(v); sz[u] += sz[v]; ans += (i64)sz[v] * (n - sz[v]) * (len[v] - len[u]); }}void dickdreamer() { std::string s; std::cin &gt;&gt; s; n = s.size(); for (int i = n - 1; ~i; --i) ins(s[i] - 'a'); for (int i = 2; i &lt;= tot; ++i) G[fa[i]].emplace_back(i); dfs(1); std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/07/22/P4248-AHOI2013-%E5%B7%AE%E5%BC%82-%E9%A2%98%E8%A7%A3/"},{"title":"CF1804F Approximate Diameter 题解","text":"Description 给定一个 \\(n\\) 个点 \\(m\\) 条边的初始无向图，有 \\(q\\) 次更新，每次更新向图中添加一条边。设 \\(d(G_i)\\) 代表加入 \\(i\\) 条边后的图中两点之间的最大距离，你需要输出 \\(q+1\\) 个整数 \\(a_0,a_1,\\dots,a_q\\)，满足 \\(\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\le a_i\\le 2\\cdot d(G_i)\\)。 \\(n,m,q\\le 10^5\\)，图连通。 Solution 首先一个普通图的 \\(d\\) 肯定是不好求的，这题也没有让求，考虑转化。 设 \\(s_i\\) 表示加入 \\(1\\sim i\\) 条边，\\(1\\) 到其他点的最长距离，易知 \\(s_i\\leq d(G_i)\\)。 如果 \\(1\\) 在 \\(G_i\\) 的直径上，则必有 \\(s_i\\geq\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\)。如果不在直径上的话就先走到直径上，\\(s_i\\) 只会变得更大。 所以 \\(\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\leq s_i\\leq d(G_i)\\)。 显然 \\(s_i\\) 是满足条件的 \\(a_i\\)，暴力求就可以做到 \\(O(n^2)\\)。 观察到 \\(\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\leq s_i\\leq d(G_i)\\) 的右边界是没有卡满的，甚至只卡到了原来的 \\(\\dfrac{1}{2}\\)，又因为左边界是递减的，所以考虑让 \\(s_i\\) 代替后面的一部分 \\(s_j\\)。 考虑什么条件下 \\(i\\) 能代替 \\(j(i\\leq j)\\)。 根据上面的式子可得：\\(\\left\\lceil\\dfrac{d(G_j)}{2}\\right\\rceil\\leq s_j\\leq d(G_j)\\)，\\(s_i\\leq 2\\times d(G_j)\\)。 所以当 \\(s_i\\leq 2\\times s_j\\) 时 \\(i\\) 能够代替 \\(j\\)，即 \\(s_j\\geq \\left\\lceil\\dfrac{s_i}{2}\\right\\rceil\\)。由于 \\(s_i\\) 是递减的，所以可以二分 \\(j\\) 找到 \\(i\\) 能确保代替的最大的 \\(j\\)。 这样做每次 \\(s_j\\) 相比 \\(s_i\\) 会减半，所以最多会二分 \\(\\log n\\) 轮，每轮 \\(\\log q\\) 次，时间复杂度就是 \\(O(n\\log n\\log q)\\)。 注意：这里 \\(s_j&lt;\\left\\lceil\\dfrac{s_i}{2}\\right\\rceil\\) 不代表 \\(i\\) 不能代替 \\(j\\)，不过不管它对结果没什么影响。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;// #define int long longconst int kMaxN = 1e5 + 5;int n, m, q;int u[kMaxN], v[kMaxN], s[kMaxN], d[kMaxN];std::vector&lt;int&gt; G[kMaxN], nG[kMaxN];int bfs() { std::fill(d + 1, d + 1 + n, -1); std::queue&lt;int&gt; q; q.emplace(1), d[1] = 0; while (!q.empty()) { int u = q.front(); q.pop(); for (auto v : nG[u]) { if (!~d[v]) { q.emplace(v), d[v] = d[u] + 1; } } } return *std::max_element(d + 1, d + 1 + n);}int get(int x) { if (~s[x]) return s[x]; for (int i = 1; i &lt;= n; ++i) nG[i] = G[i]; for (int i = 1; i &lt;= x; ++i) nG[u[i]].emplace_back(v[i]), nG[v[i]].emplace_back(u[i]); return s[x] = bfs();}void dickdreamer() { std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m; ++i) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v), G[v].emplace_back(u); } for (int i = 1; i &lt;= q; ++i) std::cin &gt;&gt; u[i] &gt;&gt; v[i]; std::fill(s, s + 1 + q, -1); for (int i = 0, j = 0; i &lt;= q; i = j + 1) { int L = i - 1, R = q + 1; while (L + 1 &lt; R) { int mid = (L + R) &gt;&gt; 1; if (get(mid) &gt;= (get(i) + 1) / 2) L = j = mid; else R = mid; } for (int k = i; k &lt;= j; ++k) std::cout &lt;&lt; get(i) &lt;&lt; ' '; }}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; std::endl; return 0;}","link":"/2023/06/29/CF1804F-Approximate-Diameter-%E9%A2%98%E8%A7%A3/"},{"title":"P7986 [USACO21DEC] HILO P 题解","text":"Description 给定两个数 \\(n,x\\)，对于一个排列 \\(a\\)，可以进行如下操作：从前到后枚举 \\(a_i\\)，若 \\(a_i&gt;x\\) 且之前不存在 \\(j\\)，使得 \\(x&lt;a_j&lt;a_i\\)，或者 \\(a_i\\leq x\\) 且之前不存在 \\(j\\)，使得 \\(a_i&lt;a_j\\leq x\\) 就把 \\(a_i\\) 加到一个队列 \\(b\\) 里面。 定义序列 \\(a\\) 的价值为 \\(b\\) 中形如 \\(b_i&gt;x\\) 且 \\(b_{i+1}\\leq x\\) 的所有 \\(i\\) 的个数。 问所有含 \\(n\\) 个数的排列的价值总和对 \\(10^9+7\\) 取模的值。 \\(0\\leq x\\leq n\\leq 5000\\)。 link Solution 令 \\(y=n-x,a_i=x+i,b_i=x-i+1\\)，那么题目就相当于问将 \\(a,b\\) 放到一起全排列，取出其中所有不同的前缀下标最小值，问形如 \\(ab\\) 的个数。 显然是个 dp，设 \\(f_{i,j,0/1}\\) 表示当前 \\(a\\) 数组中下标的最小值为 \\(i\\)，\\(b\\) 数组中的为 \\(j\\)，且当前最后面的是 \\(a/b\\) 的价值和。 容易发现这个状态是不好做的，因为不是下标最小值的数虽然不能对价值和造成贡献，但是可能会使这个价值和的方案数变多，这样就变得难做了。如果强行把这个加到状态里的话，可能又会 TLE。 那么怎样才能把那些无效的数造成的影响去除呢？ 注意到题目中的方案数是一定的，为 \\(n!\\)，所以可设 \\(f_{i,j,0/1}\\) 表示还有 \\(i\\) 个有效的 \\(a\\)，\\(j\\) 个有效的 \\(b\\)，且填完这 \\(i+j\\) 个数之前，最后面的是 \\(a/b\\) 的价值和的期望。 先考虑 \\(f_{i,j,1}\\)，然后枚举下一步选的有效的数，容易知道每种选法的概率是 \\(\\displaystyle\\frac{1}{i+j}\\)。 如果选的是 \\(a_k\\)，那么下下步之后，只有 \\(k-1\\) 个有效的 \\(a\\)，\\(j\\) 个有效的 \\(b\\)，期望就是 \\(f_{k-1,j,0}\\)。 同理，如果选的是 \\(b_k\\)，那么下下步之后，只有 \\(k-1\\) 个有效的 \\(b\\)，\\(i\\) 个有效的 \\(a\\)，由于这样期望就是 \\(f_{i,k-1,1}\\)。 然后考虑 \\(f_{i,j,0}\\)： 如果选的是 \\(a_k\\)，那么下下步之后，只有 \\(k-1\\) 个有效的 \\(a\\)，\\(j\\) 个有效的 \\(b\\)，期望就是 \\(f_{k-1,j,0}\\)。 如果选的是 \\(b_k\\)，那么下下步之后，只有 \\(k-1\\) 个有效的 \\(b\\)，\\(i\\) 个有效的 \\(a\\)，由于上一步选的是 \\(a\\)，而这一步选了 \\(b\\)，会对价值造成贡献，所以期望是 \\(f_{i,k-1,1}+1\\)。 所以可以列出式子： \\[ f_{i,j,1}=\\frac{1}{i+j}\\left(\\sum_{k=0}^{i-1}{f_{k,j,0}}+\\sum_{k=0}^{j-1}{f_{i,k,1}}\\right)\\\\ f_{i,j,0}=\\frac{1}{i+j}\\left(\\sum_{k=0}^{i-1}{(f_{k,j,0}+1)}+\\sum_{k=0}^{j-1}{f_{i,k,1}}\\right)=f_{i,j,1}+\\frac{i}{i+j} \\] 答案就是 \\[ \\frac{n!}{x+y}\\left(\\sum_{k=0}^{x-1}{f_{k,y,0}}+\\sum_{k=0}^{y-1}{f_{x,k,1}}\\right) \\] 直接 dp 即可做到 \\(O(n^2)\\)。 这样做是对的，但是它看起来又和不加期望的做法差异不大，而且把无效的数的影响解决了，期望为什么能做到这一点呢？ 回到状态转移方程，可以假设已知当前操作成了 \\(f_{i,j,0}\\) 所对应的局面，设 \\(s_{i,j,0/1}\\) 表示所有还有 \\(i\\) 个有效的 \\(a\\)，\\(j\\) 个有效的 \\(b\\)，且填完这 \\(i+j\\) 个数之前，最后面的是 \\(a/b\\) 的方案数。不妨设 \\(l\\) 表示这 \\(s_{i,j,0}\\) 个方案中的一种 考虑枚举下一个状态 \\(f_{k,j,0}\\)，设 \\(h\\) 表示从 \\(l\\) 操作到 \\(f_{k,j,0}\\) 这个状态的的所有方案数，\\(m\\) 表示这 \\(h\\) 个方案中的一个。 那么 \\(l\\) 状态对 \\(f_{i,j,0}\\) 的贡献即为 \\(\\displaystyle\\frac{1}{s_{i,j,0}}\\sum_{m}{\\frac{1}{h}f_{k,j,0}=\\frac{f_{k,j,0}}{s_{i,j,0}}}\\)，会发现再对所有的 \\(l\\)，共 \\(s_{i,j,0}\\) 个方案求和就是 \\(f_{k,j,0}\\)，这就把无效数的影响解决了。 其实这就是期望的线性性质。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;// #define int int64_tusing i64 = int64_t;const int kMaxN = 5005, kMod = 1e9 + 7;int n, x;int inv[kMaxN], s1[kMaxN], s2[kMaxN];void dickdreamer() { std::cin &gt;&gt; n &gt;&gt; x; inv[1] = 1; for (int i = 2; i &lt;= n; ++i) inv[i] = (i64)(kMod - kMod / i) * inv[kMod % i] % kMod; for (int i = 0; i &lt;= n - x; ++i) { for (int j = 0; j &lt;= x; ++j) { int ff = (i64)inv[i + j] * (s1[j] + s2[i]) % kMod, f = (ff + (i64)j * inv[i + j] % kMod) % kMod; s1[j] = (s1[j] + f) % kMod; s2[i] = (s2[i] + ff) % kMod; if (i == n - x &amp;&amp; j == x) { for (int k = 1; k &lt;= n; ++k) ff = (i64)ff * k % kMod; std::cout &lt;&lt; ff &lt;&lt; '\\n'; return; } } }}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;} Summary OI 里面的 dp 求和题如果总状态数一定，且状态外的东西对 dp 状态只对方案数有影响，对实际权值没有影响，那么就可以转化为求期望和，有时看似差异不大，但是可以把那些状态外东西的影响消除。","link":"/2023/08/21/P7986-USACO21DEC-HILO-P-%E9%A2%98%E8%A7%A3/"},{"title":"P9371 [APIO2023] 序列 题解","text":"Description link Solution 首先考虑一个序列的中位数满足什么条件。 设中位数 \\(a\\) 的个数是 \\(x\\)，小于中位数的个数是 \\(y\\)，大于中位数的个数是 \\(z\\)。 那么满足下面两个条件：\\(x+y\\geq z,x+z\\geq y\\)。 转化一下就是：\\(-x\\leq z-y\\leq x\\)。 考虑给区间里小于 \\(a\\) 的数赋一个权值 \\(-1\\)，大于 \\(a\\) 的赋 \\(1\\)，等于 \\(a\\) 为 \\(0\\)。设 \\(sum_k\\) 为权值的前缀和，\\(cnt_k\\) 为这个前缀的 \\(a\\) 的个数。 就是求满足 \\(cnt_{l-1}-cnt_r\\leq sum_r-sum_{l-1}\\leq cnt_r-cnt_{l-1}\\) 的区间 \\([l,r]\\) 中最大的 \\(cnt_r-cnt_{l-1}\\)。 考虑从小到大枚举 \\(a\\)，容易发现 \\(cnt\\) 和 \\(sum\\) 都可以用线段树维护，这里不再赘述。 把上面那个式子转化一下得：\\(sum_{l-1}+cnt_{l-1}\\leq sum_r+cnt_r\\) 且 \\(cnt_{l-1}-sum_{l-1}\\leq cnt_r-sum_r\\)。 容易发现这是一个二维偏序的结构，所以把 \\((sum_{x}+cnt_{x},cnt_{x}-sum_x)\\) 看成一个点，就只要求一个二维偏序了。 暴力是 \\(O(n^2\\log n)\\)。 考虑优化。 观察一下这些点的走势会发现 \\(A_x=a\\) 时会向右上走，\\(A_x&lt;a\\) 向左上，\\(A_x&gt;a\\) 向右下。 于是可以画出样例 2 中 \\(a=1\\) 的图像： 会发现 \\(cnt\\) 相同的点在同一条 \\(y=-x+2\\times cnt\\) 的直线上，问题就转化为：给定若干条斜率为 \\(-1\\) 的线段，求出所有线段 \\(l_1,l_2\\)，满足 \\(l_1\\) 上存在点在 \\(l_2\\) 的任一点的右上方的最大的 \\(l_1\\) 与 \\(l_2\\) 的距离。 假设给定 \\(l_2\\)，那么 \\(l_1\\) 就要满足与下面的阴影有交点： 写成式子就是：\\(maxx_1\\geq minx_2,maxy_1\\geq miny_2,cnt_1\\geq cnt_2\\)。容易发现这个式子是充分必要的。 所以只要把每条斜率为 \\(-1\\) 的线段的 \\((minx,miny)\\) 和 \\((maxx,maxy)\\) 求出来，跑二维偏序即可。 （树状数组维护 \\(cnt\\) 的最小值，这里不用考虑 \\(cnt_1\\geq cnt_2\\) 的条件，因为 \\(cnt_1 &lt; cnt_2\\) 时一定不是最优解。） 均摊下来就是 \\(O(n\\log n)\\)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &quot;sequence.h&quot;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;const int kMaxN = 5e5 + 5;struct Node { int mxx, mxy, mix, miy; Node() {} Node(int _mxx, int _mxy, int _mix, int _miy) : mxx(_mxx), mxy(_mxy), mix(_mix), miy(_miy) {}};struct LYX { pii p; int op, id; LYX() {} LYX(pii _p, int _op, int _id) : p(_p), op(_op), id(_id) {}};int n;int a[kMaxN], mxx[kMaxN &lt;&lt; 2], mxy[kMaxN &lt;&lt; 2], mix[kMaxN &lt;&lt; 2], miy[kMaxN &lt;&lt; 2], tagx[kMaxN &lt;&lt; 2], tagy[kMaxN &lt;&lt; 2];int tr[kMaxN &lt;&lt; 2];std::vector&lt;int&gt; pos[kMaxN];LYX pp[kMaxN &lt;&lt; 1];bool cmp(const LYX &amp;l1, const LYX &amp;l2) { return l1.p.first &lt; l2.p.first;}Node merge(Node ls, Node rs) { return Node(std::max(ls.mxx, rs.mxx), std::max(ls.mxy, rs.mxy), std::min(ls.mix, rs.mix), std::min(ls.miy, rs.miy));}void pushup(int x) { mxx[x] = std::max(mxx[x &lt;&lt; 1], mxx[x &lt;&lt; 1 | 1]); mix[x] = std::min(mix[x &lt;&lt; 1], mix[x &lt;&lt; 1 | 1]); mxy[x] = std::max(mxy[x &lt;&lt; 1], mxy[x &lt;&lt; 1 | 1]); miy[x] = std::min(miy[x &lt;&lt; 1], miy[x &lt;&lt; 1 | 1]);}void addtagx(int x, int v) { mxx[x] += v, mix[x] += v, tagx[x] += v;}void addtagy(int x, int v) { mxy[x] += v, miy[x] += v, tagy[x] += v;}void pushdown(int x) { if (!tagx[x] &amp;&amp; !tagy[x]) return; if (tagx[x]) addtagx(x &lt;&lt; 1, tagx[x]), addtagx(x &lt;&lt; 1 | 1, tagx[x]); if (tagy[x]) addtagy(x &lt;&lt; 1, tagy[x]), addtagy(x &lt;&lt; 1 | 1, tagy[x]); tagx[x] = tagy[x] = 0;}void update(int x, int l, int r, int ql, int qr, int vx, int vy) { if (l &gt; qr || r &lt; ql) { return; } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return addtagx(x, vx), addtagy(x, vy); } pushdown(x); int mid = (l + r) &gt;&gt; 1; update(x &lt;&lt; 1, l, mid, ql, qr, vx, vy), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, vx, vy); pushup(x);}Node query(int x, int l, int r, int ql, int qr) { if (l &gt; qr || r &lt; ql) { return Node(-1e9, -1e9, 1e9, 1e9); } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return Node(mxx[x], mxy[x], mix[x], miy[x]); } pushdown(x); int mid = (l + r) &gt;&gt; 1; Node ls = query(x &lt;&lt; 1, l, mid, ql, qr), rs = query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return merge(ls, rs);}void upd(int x, int v) { for (; x &lt;= 2e6; x += x &amp; -x) tr[x] = std::min(tr[x], v);}int qry(int x) { int ret = 1e9; for (; x; x -= x &amp; -x) ret = std::min(ret, tr[x]); return ret;}void clr(int x) { for (; x &lt;= 2e6; x += x &amp; -x) tr[x] = 1e9;}int solve(int val = 1) { for (int i = 1; i &lt;= n; ++i) update(1, 0, n, i, n, 1, -1); int ret = 0; memset(tr, 0x3f, sizeof(tr)); for (int i = 1; i &lt;= n; ++i) { for (auto x : pos[i]) if (x &amp;&amp; x &lt;= n) update(1, 0, n, x, n, 0, 2); int cnt = 0; for (int j = 0; j + 1 &lt; static_cast&lt;int&gt;(pos[i].size()); ++j) { auto p = query(1, 0, n, pos[i][j], pos[i][j + 1] - 1); pp[++cnt] = LYX(std::make_pair(p.mix, p.miy), 0, j); pp[++cnt] = LYX(std::make_pair(p.mxx, p.mxy), 1, j); } std::sort(pp + 1, pp + 1 + cnt, cmp); int now = 0; for (int j = 1, k; j &lt;= cnt; j = k) { now = j; for (k = j; k &lt;= cnt &amp;&amp; pp[k].p.first == pp[j].p.first; ++k) if (pp[k].op == 0) upd(pp[k].p.second + 1e6, pp[k].id); for (int s = j; s &lt; k; ++s) if (pp[s].op == 1) ret = std::max(ret, pp[s].id - qry(pp[s].p.second + 1e6)); } for (int k = 1; k &lt; now; ++k) clr(pp[k].p.second + 1e6); for (auto x : pos[i]) if (x &amp;&amp; x &lt;= n) update(1, 0, n, x, n, -2, 0); } return ret;}int sequence(int N, std::vector&lt;int&gt; A) { n = N; for (int i = 0; i &lt; n; ++i) a[i + 1] = A[i]; for (int i = 1; i &lt;= n; ++i) pos[i].emplace_back(0); for (int i = 1; i &lt;= n; ++i) pos[a[i]].emplace_back(i); for (int i = 1; i &lt;= n; ++i) pos[i].emplace_back(n + 1); return solve();}","link":"/2023/06/26/P9371-APIO2023-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/"},{"title":"扫描线学习笔记","text":"Part 0 前言 其实很久以前就自己看过扫描线，但是由于水平不够+没搞懂的不去搞所以也就今天才真正弄明白了。 Part 1 算法用途 解决在坐标轴上一些与图形有关的问题，包括一堆矩形并的面积、周长等等。 Part 2 算法思想 顾名思义，就是用一条线在坐标轴上扫来扫去。 以求矩形并的面积为例： 现在有 \\(n\\) 个矩形，矩形的四个点的 \\(x\\) 和 \\(y\\) 坐标都 \\(\\in [0,10^9]\\) 且为整点，问这些矩形并起来的面积（\\(n\\leq 10^5\\)）。 有一个思路就是对于每个矩形暴力打标记，然后看被标记的点数，时间复杂度：\\(O(V^2)\\)。 这样做显然是会爆炸的而且坐标还必须是整数。 考虑优化。 注意到值域是远大于 \\(n\\) 的，所以可以把矩形四个点的 \\(x\\) 和 \\(y\\) 离散化下来，这样整个坐标轴就被这些离散化下来的横线和竖线给分割成很多个网格，每个网格里的点是否被标记的状态显然是相同的，所以可以像上面那样暴力打标记，时间复杂度：\\(O(n^2)\\)。 像这样： 就直接求每个标蓝网格的面积即可 其实算法可以做得更优，设一个矩形为 \\((x_1,y_1)-(x_2,y_2)\\)，类似于差分，可以把它拆成入边和出边。 入边表示在 \\(x_1\\) 把 \\([y_1,y_2]\\) 的覆盖层数 \\(+1\\)，出边表示在 \\(x_2\\) 把 \\([y_1,y_2]\\) 覆盖层数 \\(-1\\)，然后依次扫描离散化出来的线，最后被需要计入总答案的就是当前覆盖层数 \\(\\geq 1\\) 的线段总长度 \\(\\times\\) 当前两条相邻的线截出的长度，直接数据结构维护可以做到 \\(O(n\\log n)\\)（详细维护方法见例题）。 上面就是扫描线的流程，也就是把直线离散化然后对于被两条相邻的线截开的区域用数据结构维护。 Part 3 例题 P5490 【模板】扫描线 就是上面的模板，然后用线段树维护。 由于要维护当前覆盖层数 \\(\\geq 1\\) 的点的个数，考虑记录区间 \\(\\min\\) 值、区间 \\(\\min\\) 值出现的线段的长度和区间不为 \\(0\\) 的所有线段的长度。 这个显然是可以维护的，前两个直接搞。后面的那个如果区间 \\(\\min\\) 值为 \\(0\\)，答案就是区间总长度 \\(-\\) 区间 \\(\\min\\) 值的线段长度。 如果区间 \\(\\min\\) 值不为 \\(0\\)，答案就是区间总长度。 时间复杂度：\\(O(n\\log n)\\)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;vector&gt;#define int long longconst int kMaxN = 2e5 + 5;int n, m, k;int x1[kMaxN], y1[kMaxN], x2[kMaxN], y2[kMaxN], b[kMaxN], lsh[kMaxN];int sum[kMaxN &lt;&lt; 2], mini[kMaxN &lt;&lt; 2], cnt[kMaxN &lt;&lt; 2], tag[kMaxN &lt;&lt; 2];std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; v[kMaxN];void discrete() { std::sort(b + 1, b + 1 + m), std::sort(lsh + 1, lsh + 1 + k); m = std::unique(b + 1, b + 1 + m) - (b + 1); k = std::unique(lsh + 1, lsh + 1 + k) - (lsh + 1); for (int i = 1; i &lt;= n; ++i) { y1[i] = std::lower_bound(lsh + 1, lsh + 1 + k, y1[i]) - lsh; y2[i] = std::lower_bound(lsh + 1, lsh + 1 + k, y2[i]) - lsh; v[std::lower_bound(b + 1, b + 1 + m, x1[i]) - b].emplace_back(y1[i], y2[i], 1); v[std::lower_bound(b + 1, b + 1 + m, x2[i]) - b].emplace_back(y1[i], y2[i], -1); }}void pushup(int x) { sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1]; if (mini[x &lt;&lt; 1] &lt; mini[x &lt;&lt; 1 | 1]) { mini[x] = mini[x &lt;&lt; 1], cnt[x] = cnt[x &lt;&lt; 1]; } else if (mini[x &lt;&lt; 1] &gt; mini[x &lt;&lt; 1 | 1]) { mini[x] = mini[x &lt;&lt; 1 | 1], cnt[x] = cnt[x &lt;&lt; 1 | 1]; } else { mini[x] = mini[x &lt;&lt; 1], cnt[x] = cnt[x &lt;&lt; 1] + cnt[x &lt;&lt; 1 | 1]; }}void addtag(int x, int l, int r, int v) { tag[x] += v, mini[x] += v; if (mini[x]) sum[x] = lsh[r + 1] - lsh[l]; else sum[x] = lsh[r + 1] - lsh[l] - cnt[x];}void pushdown(int x, int l, int r) { if (!tag[x]) return; int mid = (l + r) &gt;&gt; 1; addtag(x &lt;&lt; 1, l, mid, tag[x]), addtag(x &lt;&lt; 1 | 1, mid + 1, r, tag[x]); tag[x] = 0;}void build(int x, int l, int r) { if (l == r) { cnt[x] = lsh[r + 1] - lsh[l]; return; } int mid = (l + r) &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);}void update(int x, int l, int r, int ql, int qr, int v) { if (l &gt; qr || r &lt; ql) { return; } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return addtag(x, l, r, v); } pushdown(x, l, r); int mid = (l + r) &gt;&gt; 1; update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(x);}void dickdreamer() { std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { std::cin &gt;&gt; x1[i] &gt;&gt; y1[i] &gt;&gt; x2[i] &gt;&gt; y2[i]; b[++m] = x1[i]; b[++m] = x2[i]; lsh[++k] = y1[i]; lsh[++k] = y2[i]; } discrete(); long long ans = 0; build(1, 1, k - 1); for (int i = 1; i &lt; m; ++i) { for (auto p : v[i]) { int l = std::get&lt;0&gt;(p), r = std::get&lt;1&gt;(p), c = std::get&lt;2&gt;(p); update(1, 1, k - 1, l, r - 1, c); } ans += 1ll * (b[i + 1] - b[i]) * sum[1]; } std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() { std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl; return 0;} 未完待续.......","link":"/2023/06/28/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"P7987 [USACO21DEC] Paired Up G 题解","text":"Description 数轴上总计有 \\(N\\)（\\(1\\le N\\le 10^5\\)）头奶牛。第 \\(i\\) 头奶牛的位置为 \\(x_i\\)（\\(0 \\leq x_i \\leq 10^9\\)），而第 \\(i\\) 头奶牛的重量为 \\(y_i\\)（\\(1 \\leq y_i \\leq 10^4\\)）。 根据 Farmer John 的信号，某些奶牛会组成对，使得 每一对包含位置相差不超过 \\(K\\) 的两头不同的奶牛 \\(a\\) 和 \\(b\\)（\\(1\\le K\\le 10^9\\)）；也就是说，\\(|x_a-x_b|\\le K\\)。 每一头奶牛要么包含在恰好一对中，要么不属于任何一对。 配对是极大的；也就是说，没有两头未配对的奶牛可以组成对。 你需要求出未配对的奶牛的重量之和的可能的范围。具体地说， 如果 \\(T=1\\)，计算未配对的奶牛的最小重量和。 如果 \\(T=2\\)，计算未配对的奶牛的最大重量和。 link Solution 先把位置排个序，如果是问最大值那么就每个数乘 \\(-1\\)，最后取反即可。 注意到如果把所有没有配对的奶牛删掉，剩下的奶牛一定满足相邻的位置差 \\(\\leq k\\)。 考虑 DP。 设 \\(f_{i,0/1}\\) 表示已经处理了 \\(1\\sim i\\) 这些奶牛，删掉了 偶数/奇数 头奶牛，删掉的奶牛的总和最小值，\\(l\\) 表示位置 \\(&lt; x_i-k\\) 的位置最大的奶牛，\\(j=i\\bmod 2\\)。 然后就是分类讨论： \\(1\\sim i-1\\) 剩下偶数个 \\(i\\) 删掉 那么 \\(1\\sim i\\) 仍然剩下偶数个，并且上一个删掉的一定在 \\(l\\) 之前，所以 \\(f_{i,j}\\leftarrow f_{l,1-j}+y_i\\)。 \\(i\\) 不删 那么 \\(1\\sim i\\) 剩下奇数个，并且要满足 \\(x_{i+1}-x_{i}\\leq k\\)，因为这时候 \\(i\\) 是剩下的编号为奇数的奶牛，要和 \\(i+1\\) 之后的奶牛进行配对，一定要满足这个条件。所以 \\(f_{i,1-j}\\leftarrow f_{i-1,1-j}\\)。 \\(1\\sim i-1\\) 剩下奇数个 \\(i\\) 删掉 上一个删掉的一定在 \\(l\\) 之前，并且这时 \\(i-1\\) 要和 \\(i+1\\) 之后的奶牛进行配对，所以要满足 \\(x_{i+1}-x_{i-1}\\leq k\\)。那么 \\(f_{i,1-j}\\leftarrow f_{l,j}+y_i\\)。 \\(i\\) 不删 那么 \\(1\\sim i\\) 剩下偶数个，并且 \\(i\\) 和 \\(i-1\\) 及之前的要配对，所以满足 \\(x_{i}-x_{i-1}\\leq k\\) 才可以转移，则 \\(f_{i,j}\\leftarrow f_{i-1,j}\\)。 时间复杂度：\\(O(n)\\)。 其实仔细思考会发现上面状态转移的条件只是必要的，不够充分，下面证明下各个转移的条件放到一起为啥就对了。 先假设 \\(1\\sim i-1\\) 的条件都是正确的，那么 2,2 里面如果不满足 \\(x_i-x_{i-1}\\leq k\\)，显然 \\(i\\) 前面那个没被删的就找不到和他配对的了。满足了 \\(x_{i}-x_{i-1}\\leq k\\)，状态就相当于转化为“\\(1\\sim i-1\\)，剩下了奇数个奶牛”，也就是状态 1.2 和 2.1，1.2 的条件满足了 \\(i-1\\) 不删的情况。2.1 由于 \\(x_l&lt;x_{i-1}-k\\)，所以 \\(l+1\\sim i-2\\) 都没删，所以 \\(1\\sim i-1\\) 那个编号最大的没删的一定是 \\(i-2\\)，所以 \\(i-2\\) 要与 \\(i\\) 配对，条件就派上了用场。 然后是 1.2，如果不满足 \\(x_{i+1}-x_i\\leq k\\)，\\(i\\) 就找不到他后面的奶牛了，显然不行。满足了 \\(x_{i+1}-x_i\\leq k\\)，相当于钦定 \\(i\\) 能找到后面的，那么 \\(f_{i-1,1-j}\\) 就可以直接转移了。 最后是 2.1，由 2.2 的分析可知 \\(1\\sim i\\) 里面最后的一个没删的奶牛一定是 \\(i-1\\)，钦定他能找到后面的，就可以直接转移。 综上所述，1.2 和 2.1 相当于钦定后面满足的条件，然后 2.2 的条件刚好符合 1.2 和 2.1 所钦定的条件，即可转移得万无一失。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define int int64_tconst int kMaxN = 1e5 + 5;int t, n, k, op = 1;int f[kMaxN][2];std::pair&lt;int, int&gt; a[kMaxN];void dickdreamer() { std::cin &gt;&gt; t &gt;&gt; n &gt;&gt; k; if (t == 2) op = -1; for (int i = 1; i &lt;= n; ++i) { std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second; a[i].second *= op; } std::sort(a + 1, a + 1 + n); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; a[0].first = -1e12, a[n + 1].first = 1e12; int lst = 0; for (int i = 1; i &lt;= n; ++i) { for (; a[lst + 1].first &lt; a[i].first - k; ++lst) {} int j = (i &amp; 1); f[i][j] = std::min(f[i][j], f[lst][j ^ 1] + a[i].second); if (a[i + 1].first - a[i].first &lt;= k) f[i][j ^ 1] = std::min(f[i][j ^ 1], f[i - 1][j ^ 1]); if (a[i + 1].first - a[i - 1].first &lt;= k) f[i][j ^ 1] = std::min(f[i][j ^ 1], f[lst][j] + a[i].second); if (a[i].first - a[i - 1].first &lt;= k) f[i][j] = std::min(f[i][j], f[i - 1][j]); } std::cout &lt;&lt; f[n][n &amp; 1] * op &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/08/22/P7987-USACO21DEC-Paired-Up-G-%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"APIO","slug":"APIO","link":"/tags/APIO/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"扫描线","slug":"扫描线","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"USACO","slug":"USACO","link":"/tags/USACO/"},{"name":"DP","slug":"DP","link":"/tags/DP/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"题解/贪心","link":"/categories/%E9%A2%98%E8%A7%A3/%E8%B4%AA%E5%BF%83/"},{"name":"数学","slug":"题解/数学","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"题解/图论","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"},{"name":"字符串","slug":"题解/字符串","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分","slug":"题解/二分","link":"/categories/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86/"},{"name":"斯特林数","slug":"题解/数学/斯特林数","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"期望","slug":"题解/数学/期望","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E6%9C%9F%E6%9C%9B/"},{"name":"数据结构","slug":"题解/数据结构","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"拓扑排序","slug":"题解/图论/拓扑排序","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DP","slug":"题解/DP","link":"/categories/%E9%A2%98%E8%A7%A3/DP/"},{"name":"后缀自动机","slug":"题解/字符串/后缀自动机","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树","slug":"题解/数据结构/线段树","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计算几何","slug":"学习笔记/计算几何","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"扫描线","slug":"学习笔记/计算几何/扫描线","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E6%89%AB%E6%8F%8F%E7%BA%BF/"}],"pages":[{"title":"archives","text":"","link":"/archives/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于","text":"一个菜鸡 OIer 的博客，主要记录一些题解和有趣的东西。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}]}