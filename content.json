{"posts":[{"title":"CF1804D Accommodation 题解","text":"Description link Solution 由于行与行之间独立，所以可以对每行分别求最大和最小值。 先考虑最小值。 先找出每段 111 的长度，显然是尽量往里面放双人房，如果所需双人房个数 &gt;m4&gt;\\dfrac{m}{4}&gt;4m​，那么就删掉一些双人房然后塞单人房即可。 然后是最大值。 设 111 的个数为 ccc，那么答案就是 ccc 减双人房中两个都是 111 的房间个数。 考虑双人房中两个都是 111 的最小房间个数怎么求，由于这个又等于 m4\\dfrac{m}{4}4m​ 减双人房中有至少一个为 000 房间个数。 至少一个为 000 的个数就从前往后扫，如果发现 ai+ai+1&lt;2a_i+a_{i+1}&lt;2ai​+ai+1​&lt;2 就用双人房，然后跳到 i+2i+2i+2 继续搞。 这样做显然是对的，证明如下： 考虑把 000 和他们两边的 111 的区间最边上的 111 合并成一个大区间 [li,ri][l_i,r_i][li​,ri​]，如果两个 000 区间中间只隔了 111 个 111 那么把他们也合并了。 容易发现区间不会相交。上面那个操作就是在每个区间里找最多不相交的二连线段个数，显然从前往后扫是最优的。 至少一个为 000 的个数如果大于 m4\\dfrac{m}{4}4m​ 就取到 m4\\dfrac{m}{4}4m​。 时间复杂度：O(nm)O(nm)O(nm)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;iostream&gt;// #define int long longconst int kMaxN = 5e5 + 5;int n, m;int a[kMaxN], b[kMaxN];int getmin(std::string s) { int cnt2 = m / 4, k = 0; for (int i = 1; i &lt;= m; ++i) a[i] = s[i] - '0'; int lst = 0; for (int i = 1; i &lt;= m; ++i) { if (a[i]) ++lst; if (!a[i + 1] &amp;&amp; lst) { b[++k] = lst, lst = 0; } } int sum = 0, tot = 0; for (int i = 1; i &lt;= k; ++i) { sum += b[i] / 2; tot += b[i]; } if (sum &lt;= cnt2) return sum + tot - 2 * sum; else return cnt2 + tot - 2 * cnt2;}int getmax(std::string s) { int cnt2 = m / 4, k = 0, ret = 0; for (int i = 1; i &lt;= m; ++i) { a[i] = s[i] - '0'; ret += a[i]; } for (int i = 1; i &lt; m;) { if (!a[i] || !a[i + 1]) { ++k, i += 2; } else { ++i; } } return ret - (cnt2 - std::min(cnt2, k));}void dickdreamer() { int mi = 0, mx = 0; std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { std::string s; std::cin &gt;&gt; s; s = &quot; &quot; + s; mi += getmin(s), mx += getmax(s); } std::cout &lt;&lt; mi &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; std::endl; return 0;}","link":"/2023/06/27/CF1804D-Accommodation-%E9%A2%98%E8%A7%A3/"},{"title":"CF1804F Approximate Diameter 题解","text":"Description 给定一个 nnn 个点 mmm 条边的初始无向图，有 qqq 次更新，每次更新向图中添加一条边。设 d(Gi)d(G_i)d(Gi​) 代表加入 iii 条边后的图中两点之间的最大距离，你需要输出 q+1q+1q+1 个整数 a0,a1,…,aqa_0,a_1,\\dots,a_qa0​,a1​,…,aq​，满足 ⌈d(Gi)2⌉≤ai≤2⋅d(Gi)\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\le a_i\\le 2\\cdot d(G_i)⌈2d(Gi​)​⌉≤ai​≤2⋅d(Gi​)。 n,m,q≤105n,m,q\\le 10^5n,m,q≤105，图连通。 Solution 首先一个普通图的 ddd 肯定是不好求的，这题也没有让求，考虑转化。 设 sis_isi​ 表示加入 1∼i1\\sim i1∼i 条边，111 到其他点的最长距离，易知 si≤d(Gi)s_i\\leq d(G_i)si​≤d(Gi​)。 如果 111 在 GiG_iGi​ 的直径上，则必有 si≥⌈d(Gi)2⌉s_i\\geq\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceilsi​≥⌈2d(Gi​)​⌉。如果不在直径上的话就先走到直径上，sis_isi​ 只会变得更大。 所以 ⌈d(Gi)2⌉≤si≤d(Gi)\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\leq s_i\\leq d(G_i)⌈2d(Gi​)​⌉≤si​≤d(Gi​)。 显然 sis_isi​ 是满足条件的 aia_iai​，暴力求就可以做到 O(n2)O(n^2)O(n2)。 观察到 ⌈d(Gi)2⌉≤si≤d(Gi)\\left\\lceil\\dfrac{d(G_i)}{2}\\right\\rceil\\leq s_i\\leq d(G_i)⌈2d(Gi​)​⌉≤si​≤d(Gi​) 的右边界是没有卡满的，甚至只卡到了原来的 12\\dfrac{1}{2}21​，又因为左边界是递减的，所以考虑让 sis_isi​ 代替后面的一部分 sjs_jsj​。 考虑什么条件下 iii 能代替 j(i≤j)j(i\\leq j)j(i≤j)。 根据上面的式子可得：⌈d(Gj)2⌉≤sj≤d(Gj)\\left\\lceil\\dfrac{d(G_j)}{2}\\right\\rceil\\leq s_j\\leq d(G_j)⌈2d(Gj​)​⌉≤sj​≤d(Gj​)，si≤2×d(Gj)s_i\\leq 2\\times d(G_j)si​≤2×d(Gj​)。 所以当 si≤2×sjs_i\\leq 2\\times s_jsi​≤2×sj​ 时 iii 能够代替 jjj，即 sj≥⌈si2⌉s_j\\geq \\left\\lceil\\dfrac{s_i}{2}\\right\\rceilsj​≥⌈2si​​⌉。由于 sis_isi​ 是递减的，所以可以二分 jjj 找到 iii 能确保代替的最大的 jjj。 这样做每次 sjs_jsj​ 相比 sis_isi​ 会减半，所以最多会二分 log⁡n\\log nlogn 轮，每轮 log⁡q\\log qlogq 次，时间复杂度就是 O(nlog⁡nlog⁡q)O(n\\log n\\log q)O(nlognlogq)。 注意：这里 sj&lt;⌈si2⌉s_j&lt;\\left\\lceil\\dfrac{s_i}{2}\\right\\rceilsj​&lt;⌈2si​​⌉ 不代表 iii 不能代替 jjj，不过不管它对结果没什么影响。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;// #define int long longconst int kMaxN = 1e5 + 5;int n, m, q;int u[kMaxN], v[kMaxN], s[kMaxN], d[kMaxN];std::vector&lt;int&gt; G[kMaxN], nG[kMaxN];int bfs() { std::fill(d + 1, d + 1 + n, -1); std::queue&lt;int&gt; q; q.emplace(1), d[1] = 0; while (!q.empty()) { int u = q.front(); q.pop(); for (auto v : nG[u]) { if (!~d[v]) { q.emplace(v), d[v] = d[u] + 1; } } } return *std::max_element(d + 1, d + 1 + n);}int get(int x) { if (~s[x]) return s[x]; for (int i = 1; i &lt;= n; ++i) nG[i] = G[i]; for (int i = 1; i &lt;= x; ++i) nG[u[i]].emplace_back(v[i]), nG[v[i]].emplace_back(u[i]); return s[x] = bfs();}void dickdreamer() { std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m; ++i) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v), G[v].emplace_back(u); } for (int i = 1; i &lt;= q; ++i) std::cin &gt;&gt; u[i] &gt;&gt; v[i]; std::fill(s, s + 1 + q, -1); for (int i = 0, j = 0; i &lt;= q; i = j + 1) { int L = i - 1, R = q + 1; while (L + 1 &lt; R) { int mid = (L + R) &gt;&gt; 1; if (get(mid) &gt;= (get(i) + 1) / 2) L = j = mid; else R = mid; } for (int k = i; k &lt;= j; ++k) std::cout &lt;&lt; get(i) &lt;&lt; ' '; }}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; std::endl; return 0;}","link":"/2023/06/29/CF1804F-Approximate-Diameter-%E9%A2%98%E8%A7%A3/"},{"title":"CF932E Team Work 题解","text":"Description 给定 n,kn,kn,k，求： ∑i=1n(ni)×ik\\displaystyle\\sum_{i=1}^{n}{\\binom{n}{i}\\times i^k} i=1∑n​(in​)×ik 1≤k≤5000,1≤n≤1091\\leq k\\leq 5000,1\\leq n\\leq 10^91≤k≤5000,1≤n≤109。 Solution 看到那个 iki^kik 很不爽，但是 kkk 很小，考虑用斯特林数改写一下： ik=∑j=0k(ij){kj}⋅j!i^k=\\sum_{j=0}^{k}{\\binom{i}{j}\\left \\{ \\begin{matrix} k\\\\ j \\end{matrix} \\right \\}\\cdot j!} ik=j=0∑k​(ji​){kj​}⋅j! 代回原式得： ∑i=0n(ni)⋅∑j=0k(ij){kj}j!=∑j=0kj!{kj}⋅∑i=0n(ni)(ij)=∑j=0kj!{kj}⋅∑i=jnn!i!(n−i)!⋅i!j!(i−j)!=n!∑j=0k{kj}⋅∑i=jn(n−ji−j)(n−j)!=n!∑j=0k1(n−j)!{kj}∑i=0n−j(n−ji)=n!∑j=0k2n−j(n−j)!⋅{kj}\\displaystyle \\begin{aligned} &amp;\\sum_{i=0}^{n}{\\binom{n}{i}\\cdot\\sum_{j=0}^{k}{\\binom{i}{j}\\left \\{ {\\begin{matrix} k\\\\ j \\end{matrix}} \\right \\} j!} }\\\\ =&amp;\\sum_{j=0}^{k}{j!\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=0}^{n}{\\binom{n}{i}\\binom{i}{j}}}\\\\ =&amp;\\sum_{j=0}^{k}{j!\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=j}^{n}{\\frac{n!}{i!(n-i)!}\\cdot \\frac{i!}{j!(i-j)!}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\cdot\\sum_{i=j}^{n}{\\frac{\\binom{n-j}{i-j}}{(n-j)!}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\frac{1}{(n-j)!}\\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}\\sum_{i=0}^{n-j}{\\binom{n-j}{i}}}\\\\ =&amp;n!\\sum_{j=0}^{k}{\\frac{2^{n-j}}{(n-j)!}\\cdot \\left\\{\\begin{matrix}k\\\\j\\end{matrix}\\right\\}}\\\\ \\end{aligned}=====​i=0∑n​(in​)⋅j=0∑k​(ji​){kj​}j!j=0∑k​j!{kj​}⋅i=0∑n​(in​)(ji​)j=0∑k​j!{kj​}⋅i=j∑n​i!(n−i)!n!​⋅j!(i−j)!i!​n!j=0∑k​{kj​}⋅i=j∑n​(n−j)!(i−jn−j​)​n!j=0∑k​(n−j)!1​{kj​}i=0∑n−j​(in−j​)n!j=0∑k​(n−j)!2n−j​⋅{kj​}​ 于是直接预处理出斯特林数即可做到 O(k2+klog⁡n)O(k^2+k\\log n)O(k2+klogn)，如果用卷积预处理的话就可以做到 O(klog⁡k+klog⁡n)O(k\\log k+k\\log n)O(klogk+klogn)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;// #define int int64_tusing i64 = int64_t;const int kMod = 1e9 + 7;int s[5005][5005];int qpow(int bs, int idx = kMod - 2) { int ret = 1; for (; idx; idx &gt;&gt;= 1, bs = (i64)bs * bs % kMod) if (idx &amp; 1) ret = (i64)ret * bs % kMod; return ret;}void dickdreamer() { int n, k, ans = 0; std::cin &gt;&gt; n &gt;&gt; k; s[0][0] = 1; for (int i = 1; i &lt;= k; ++i) { for (int j = 1; j &lt;= i; ++j) { s[i][j] = (s[i - 1][j - 1] + (i64)j * s[i - 1][j] % kMod) % kMod; } } for (int i = 0, c = 1; i &lt;= std::min(n, k); ++i) { ans = (ans + (i64)s[k][i] * c % kMod * qpow(2, n - i) % kMod) % kMod; c = (i64)c * (n - i) % kMod; } std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/08/16/CF932E-Team-Work-%E9%A2%98%E8%A7%A3/"},{"title":"P3573 [POI2014] RAJ-Rally 题解","text":"Description 给定一个 nnn 个点 mmm 条边的有向无环图，每条边长度都是 111。 请找到一个点，使得删掉这个点后剩余的图中的最长路径最短。 n≤5×105,m≤106n\\leq 5\\times 10^5,m\\leq 10^6n≤5×105,m≤106。 Solution 设 fif_ifi​ 表示以 iii 为终点的最长路，gig_igi​ 表示以 iii 为起点的最长路，did_idi​ 为 iii 的拓扑序。 这两个显然可以通过拓扑排序求出。 易知原图中的任何一个路径上的点的拓扑序一定是递增的，所以删掉一个点 uuu，剩余的路径只有 fi(di&lt;du),gi(di&gt;du),fi+gj+1(di&lt;du&lt;dj)f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)fi​(di​&lt;du​),gi​(di​&gt;du​),fi​+gj​+1(di​&lt;du​&lt;dj​) 三种可能。 那么就可以维护三个 multiset，分别维护 fi(di&lt;du),gi(di&gt;du),fi+gj+1(di&lt;du&lt;dj)f_i(d_i&lt;d_u),g_i(d_i&gt;d_u),f_i+g_j+1(d_i&lt;d_u&lt;d_j)fi​(di​&lt;du​),gi​(di​&gt;du​),fi​+gj​+1(di​&lt;du​&lt;dj​)。 前两个直接在从小到大枚举 dud_udu​ 的时候增删，第三个可以每次先加入 di=du−1d_i=d_u-1di​=du​−1 的所有边，然后删去 dj=dud_j=d_udj​=du​ 的所有边，这样可以保证 di&lt;dud_i&lt;d_udi​&lt;du​ 且 dj&gt;dud_j&gt;d_udj​&gt;du​。 时间复杂度：O((n+m)log⁡(n+m))O((n+m)\\log (n+m))O((n+m)log(n+m))。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;// #define int int64_tconst int kMaxN = 5e5 + 5;int n, m, cnt;int id[kMaxN], deg[kMaxN], f[kMaxN], g[kMaxN];std::vector&lt;int&gt; G[kMaxN], rG[kMaxN];std::multiset&lt;int&gt; s1, s2, s3;// s1 : f[u]// s2 : g[u]// s3 : f[u] + g[v] + 1(u &lt; i &lt; v)void topo() { std::queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { if (!deg[i]) { q.emplace(i), f[i] = 0; } } while (!q.empty()) { int u = q.front(); q.pop(); id[++cnt] = u; for (auto v : G[u]) { f[v] = std::max(f[v], f[u] + 1); if (!--deg[v]) q.emplace(v); } }}void dickdreamer() { std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v), rG[v].emplace_back(u); ++deg[v]; } topo(); for (int i = n; i; --i) { int u = id[i]; for (auto v : G[u]) g[u] = std::max(g[u], g[v] + 1); } for (int i = 1; i &lt;= n; ++i) s2.emplace(-g[i]); int ans = 1e9, idx = 1; for (int i = 1; i &lt;= n; ++i) { int u = id[i]; if (i) { for (auto v : G[id[i - 1]]) s3.emplace(-(f[id[i - 1]] + g[v] + 1)); } for (auto v : rG[u]) { s3.erase(s3.lower_bound(-(f[v] + g[u] + 1))); } if (i) s1.emplace(-f[id[i - 1]]); s2.erase(s2.lower_bound(-g[u])); int mx = 0; if (!s1.empty()) mx = std::max(mx, -*s1.begin()); if (!s2.empty()) mx = std::max(mx, -*s2.begin()); if (!s3.empty()) mx = std::max(mx, -*s3.begin()); if (mx &lt; ans) { ans = mx, idx = u; } } std::cout &lt;&lt; idx &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/07/07/P3573-POI2014-RAJ-Rally-%E9%A2%98%E8%A7%A3/"},{"title":"P4248 [AHOI2013] 差异 题解","text":"Description 给定一个长度为 nnn 的字符串 SSS，令 TiT_iTi​ 表示它从第 iii 个字符开始的后缀。求 ∑1≤ij≤nlen(Ti)+len(Tj)−2×lcp(Ti,Tj)\\displaystyle \\sum_{1\\leq ij\\leq n}\\text{len}(T_i)+\\text{len}(T_j)-2\\times\\text{lcp}(T_i,T_j)1≤ij≤n∑​len(Ti​)+len(Tj​)−2×lcp(Ti​,Tj​)。 其中，len(a)\\text{len}(a)len(a) 表示字符串 aaa 的长度，lcp(a,b)\\text{lcp}(a,b)lcp(a,b) 表示字符串 aaa 和字符串 bbb 的最长公共前缀。 link Solution 考虑把 SSS 的反串的 parent 树建出来。 设 TiT_iTi​ 的 endpos 等价类是 xxx，TjT_jTj​ 的 endpos 等价类是 yyy。 由于 parent 树上任意一个点的父亲一定是这个点的后缀，所以 TiT_iTi​ 和 TjT_jTj​ 的公共前缀一定就在反串 parent 树上 xxx 和 yyy 某个公共祖先所表示的等价类里，而最长的一定就在 xxx 和 yyy 的 LCA 上。 由于 Ti,TjT_i,T_jTi​,Tj​ 和 lcp(Ti,Tj)\\text{lcp}(T_i,T_j)lcp(Ti​,Tj​) 一定都是反串的前缀，所以他们的长度一定都是所在等价类最大的，那么 len(Ti)+len(Tj)−2×lcp(Ti,Tj)\\text{len}(T_i)+\\text{len}(T_j)-2\\times\\text{lcp}(T_i,T_j)len(Ti​)+len(Tj​)−2×lcp(Ti​,Tj​) 就等于 lenx+leny−2×lenlca\\text{len}_x+\\text{len}_y-2\\times \\text{len}_\\text{lca}lenx​+leny​−2×lenlca​，如果把 parent 树的边权看作相邻两点 len\\text{len}len 的差值，那么原式就是 x,yx,yx,y 的树上最短路径的长度。 然后对于每条边算贡献即可，即设 sizex\\text{size}_xsizex​ 表示 xxx 的子树里反串前缀所在的等价类的个数，答案就是 ∑(sizex×(n−sizex)×(lenx−lenfa))\\displaystyle\\sum\\left(\\text{size}_x\\times(n-\\text{size}_x)\\times(\\text{len}_x-\\text{len}_\\text{fa})\\right)∑(sizex​×(n−sizex​)×(lenx​−lenfa​))。 时间复杂度：O(n)O(n)O(n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// #define int int64_tconst int kMaxN = 1e6 + 5;using i64 = int64_t;int n, tot = 1, lst = 1, nxt[kMaxN][26], len[kMaxN], fa[kMaxN], sz[kMaxN];i64 ans;std::vector&lt;int&gt; G[kMaxN];void ins(int c) { int cur = ++tot, p = lst; lst = cur; len[cur] = len[p] + 1, sz[cur] = 1; for (; p &amp;&amp; !nxt[p][c]; p = fa[p]) nxt[p][c] = cur; if (!p) { fa[cur] = 1; } else { int q = nxt[p][c]; if (len[q] == len[p] + 1) { fa[cur] = q; } else { int nw = ++tot; fa[nw] = fa[q], len[nw] = len[p] + 1; for (int i = 0; i &lt; 26; ++i) nxt[nw][i] = nxt[q][i]; fa[q] = fa[cur] = nw; for (; p &amp;&amp; nxt[p][c] == q; p = fa[p]) nxt[p][c] = nw; } }}void dfs(int u) { for (auto v : G[u]) { dfs(v); sz[u] += sz[v]; ans += (i64)sz[v] * (n - sz[v]) * (len[v] - len[u]); }}void dickdreamer() { std::string s; std::cin &gt;&gt; s; n = s.size(); for (int i = n - 1; ~i; --i) ins(s[i] - 'a'); for (int i = 2; i &lt;= tot; ++i) G[fa[i]].emplace_back(i); dfs(1); std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() {#ifdef ORZXKR freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // std::cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; &quot;s\\n&quot;; return 0;}","link":"/2023/07/22/P4248-AHOI2013-%E5%B7%AE%E5%BC%82-%E9%A2%98%E8%A7%A3/"},{"title":"P9371 [APIO2023] 序列 题解","text":"Description link Solution 首先考虑一个序列的中位数满足什么条件。 设中位数 aaa 的个数是 xxx，小于中位数的个数是 yyy，大于中位数的个数是 zzz。 那么满足下面两个条件：x+y≥z,x+z≥yx+y\\geq z,x+z\\geq yx+y≥z,x+z≥y。 转化一下就是：−x≤z−y≤x-x\\leq z-y\\leq x−x≤z−y≤x。 考虑给区间里小于 aaa 的数赋一个权值 −1-1−1，大于 aaa 的赋 111，等于 aaa 为 000。设 sumksum_ksumk​ 为权值的前缀和，cntkcnt_kcntk​ 为这个前缀的 aaa 的个数。 就是求满足 cntl−1−cntr≤sumr−suml−1≤cntr−cntl−1cnt_{l-1}-cnt_r\\leq sum_r-sum_{l-1}\\leq cnt_r-cnt_{l-1}cntl−1​−cntr​≤sumr​−suml−1​≤cntr​−cntl−1​ 的区间 [l,r][l,r][l,r] 中最大的 cntr−cntl−1cnt_r-cnt_{l-1}cntr​−cntl−1​。 考虑从小到大枚举 aaa，容易发现 cntcntcnt 和 sumsumsum 都可以用线段树维护，这里不再赘述。 把上面那个式子转化一下得：suml−1+cntl−1≤sumr+cntrsum_{l-1}+cnt_{l-1}\\leq sum_r+cnt_rsuml−1​+cntl−1​≤sumr​+cntr​ 且 cntl−1−suml−1≤cntr−sumrcnt_{l-1}-sum_{l-1}\\leq cnt_r-sum_rcntl−1​−suml−1​≤cntr​−sumr​。 容易发现这是一个二维偏序的结构，所以把 (sumx+cntx,cntx−sumx)(sum_{x}+cnt_{x},cnt_{x}-sum_x)(sumx​+cntx​,cntx​−sumx​) 看成一个点，就只要求一个二维偏序了。 暴力是 O(n2log⁡n)O(n^2\\log n)O(n2logn)。 考虑优化。 观察一下这些点的走势会发现 Ax=aA_x=aAx​=a 时会向右上走，Ax&lt;aA_x&lt;aAx​&lt;a 向左上，Ax&gt;aA_x&gt;aAx​&gt;a 向右下。 于是可以画出样例 2 中 a=1a=1a=1 的图像： 会发现 cntcntcnt 相同的点在同一条 y=−x+2×cnty=-x+2\\times cnty=−x+2×cnt 的直线上，问题就转化为：给定若干条斜率为 −1-1−1 的线段，求出所有线段 l1,l2l_1,l_2l1​,l2​，满足 l1l_1l1​ 上存在点在 l2l_2l2​ 的任一点的右上方的最大的 l1l_1l1​ 与 l2l_2l2​ 的距离。 假设给定 l2l_2l2​，那么 l1l_1l1​ 就要满足与下面的阴影有交点： 写成式子就是：maxx1≥minx2,maxy1≥miny2,cnt1≥cnt2maxx_1\\geq minx_2,maxy_1\\geq miny_2,cnt_1\\geq cnt_2maxx1​≥minx2​,maxy1​≥miny2​,cnt1​≥cnt2​。容易发现这个式子是充分必要的。 所以只要把每条斜率为 −1-1−1 的线段的 (minx,miny)(minx,miny)(minx,miny) 和 (maxx,maxy)(maxx,maxy)(maxx,maxy) 求出来，跑二维偏序即可。 （树状数组维护 cntcntcnt 的最小值，这里不用考虑 cnt1≥cnt2cnt_1\\geq cnt_2cnt1​≥cnt2​ 的条件，因为 cnt1&lt;cnt2cnt_1 &lt; cnt_2cnt1​&lt;cnt2​ 时一定不是最优解。） 均摊下来就是 O(nlog⁡n)O(n\\log n)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &quot;sequence.h&quot;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// #define int long longusing pii = std::pair&lt;int, int&gt;;const int kMaxN = 5e5 + 5;struct Node { int mxx, mxy, mix, miy; Node() {} Node(int _mxx, int _mxy, int _mix, int _miy) : mxx(_mxx), mxy(_mxy), mix(_mix), miy(_miy) {}};struct LYX { pii p; int op, id; LYX() {} LYX(pii _p, int _op, int _id) : p(_p), op(_op), id(_id) {}};int n;int a[kMaxN], mxx[kMaxN &lt;&lt; 2], mxy[kMaxN &lt;&lt; 2], mix[kMaxN &lt;&lt; 2], miy[kMaxN &lt;&lt; 2], tagx[kMaxN &lt;&lt; 2], tagy[kMaxN &lt;&lt; 2];int tr[kMaxN &lt;&lt; 2];std::vector&lt;int&gt; pos[kMaxN];LYX pp[kMaxN &lt;&lt; 1];bool cmp(const LYX &amp;l1, const LYX &amp;l2) { return l1.p.first &lt; l2.p.first;}Node merge(Node ls, Node rs) { return Node(std::max(ls.mxx, rs.mxx), std::max(ls.mxy, rs.mxy), std::min(ls.mix, rs.mix), std::min(ls.miy, rs.miy));}void pushup(int x) { mxx[x] = std::max(mxx[x &lt;&lt; 1], mxx[x &lt;&lt; 1 | 1]); mix[x] = std::min(mix[x &lt;&lt; 1], mix[x &lt;&lt; 1 | 1]); mxy[x] = std::max(mxy[x &lt;&lt; 1], mxy[x &lt;&lt; 1 | 1]); miy[x] = std::min(miy[x &lt;&lt; 1], miy[x &lt;&lt; 1 | 1]);}void addtagx(int x, int v) { mxx[x] += v, mix[x] += v, tagx[x] += v;}void addtagy(int x, int v) { mxy[x] += v, miy[x] += v, tagy[x] += v;}void pushdown(int x) { if (!tagx[x] &amp;&amp; !tagy[x]) return; if (tagx[x]) addtagx(x &lt;&lt; 1, tagx[x]), addtagx(x &lt;&lt; 1 | 1, tagx[x]); if (tagy[x]) addtagy(x &lt;&lt; 1, tagy[x]), addtagy(x &lt;&lt; 1 | 1, tagy[x]); tagx[x] = tagy[x] = 0;}void update(int x, int l, int r, int ql, int qr, int vx, int vy) { if (l &gt; qr || r &lt; ql) { return; } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return addtagx(x, vx), addtagy(x, vy); } pushdown(x); int mid = (l + r) &gt;&gt; 1; update(x &lt;&lt; 1, l, mid, ql, qr, vx, vy), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, vx, vy); pushup(x);}Node query(int x, int l, int r, int ql, int qr) { if (l &gt; qr || r &lt; ql) { return Node(-1e9, -1e9, 1e9, 1e9); } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return Node(mxx[x], mxy[x], mix[x], miy[x]); } pushdown(x); int mid = (l + r) &gt;&gt; 1; Node ls = query(x &lt;&lt; 1, l, mid, ql, qr), rs = query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return merge(ls, rs);}void upd(int x, int v) { for (; x &lt;= 2e6; x += x &amp; -x) tr[x] = std::min(tr[x], v);}int qry(int x) { int ret = 1e9; for (; x; x -= x &amp; -x) ret = std::min(ret, tr[x]); return ret;}void clr(int x) { for (; x &lt;= 2e6; x += x &amp; -x) tr[x] = 1e9;}int solve(int val = 1) { for (int i = 1; i &lt;= n; ++i) update(1, 0, n, i, n, 1, -1); int ret = 0; memset(tr, 0x3f, sizeof(tr)); for (int i = 1; i &lt;= n; ++i) { for (auto x : pos[i]) if (x &amp;&amp; x &lt;= n) update(1, 0, n, x, n, 0, 2); int cnt = 0; for (int j = 0; j + 1 &lt; static_cast&lt;int&gt;(pos[i].size()); ++j) { auto p = query(1, 0, n, pos[i][j], pos[i][j + 1] - 1); pp[++cnt] = LYX(std::make_pair(p.mix, p.miy), 0, j); pp[++cnt] = LYX(std::make_pair(p.mxx, p.mxy), 1, j); } std::sort(pp + 1, pp + 1 + cnt, cmp); int now = 0; for (int j = 1, k; j &lt;= cnt; j = k) { now = j; for (k = j; k &lt;= cnt &amp;&amp; pp[k].p.first == pp[j].p.first; ++k) if (pp[k].op == 0) upd(pp[k].p.second + 1e6, pp[k].id); for (int s = j; s &lt; k; ++s) if (pp[s].op == 1) ret = std::max(ret, pp[s].id - qry(pp[s].p.second + 1e6)); } for (int k = 1; k &lt; now; ++k) clr(pp[k].p.second + 1e6); for (auto x : pos[i]) if (x &amp;&amp; x &lt;= n) update(1, 0, n, x, n, -2, 0); } return ret;}int sequence(int N, std::vector&lt;int&gt; A) { n = N; for (int i = 0; i &lt; n; ++i) a[i + 1] = A[i]; for (int i = 1; i &lt;= n; ++i) pos[i].emplace_back(0); for (int i = 1; i &lt;= n; ++i) pos[a[i]].emplace_back(i); for (int i = 1; i &lt;= n; ++i) pos[i].emplace_back(n + 1); return solve();}","link":"/2023/06/26/P9371-APIO2023-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/"},{"title":"扫描线学习笔记","text":"Part 0 前言 其实很久以前就自己看过扫描线，但是由于水平不够+没搞懂的不去搞所以也就今天才真正弄明白了。 Part 1 算法用途 解决在坐标轴上一些与图形有关的问题，包括一堆矩形并的面积、周长等等。 Part 2 算法思想 顾名思义，就是用一条线在坐标轴上扫来扫去。 以求矩形并的面积为例： 现在有 nnn 个矩形，矩形的四个点的 xxx 和 yyy 坐标都 ∈[0,109]\\in [0,10^9]∈[0,109] 且为整点，问这些矩形并起来的面积（n≤105n\\leq 10^5n≤105）。 有一个思路就是对于每个矩形暴力打标记，然后看被标记的点数，时间复杂度：O(V2)O(V^2)O(V2)。 这样做显然是会爆炸的而且坐标还必须是整数。 考虑优化。 注意到值域是远大于 nnn 的，所以可以把矩形四个点的 xxx 和 yyy 离散化下来，这样整个坐标轴就被这些离散化下来的横线和竖线给分割成很多个网格，每个网格里的点是否被标记的状态显然是相同的，所以可以像上面那样暴力打标记，时间复杂度：O(n2)O(n^2)O(n2)。 像这样： 就直接求每个标蓝网格的面积即可 其实算法可以做得更优，设一个矩形为 (x1,y1)−(x2,y2)(x_1,y_1)-(x_2,y_2)(x1​,y1​)−(x2​,y2​)，类似于差分，可以把它拆成入边和出边。 入边表示在 x1x_1x1​ 把 [y1,y2][y_1,y_2][y1​,y2​] 的覆盖层数 +1+1+1，出边表示在 x2x_2x2​ 把 [y1,y2][y_1,y_2][y1​,y2​] 覆盖层数 −1-1−1，然后依次扫描离散化出来的线，最后被需要计入总答案的就是当前覆盖层数 ≥1\\geq 1≥1 的线段总长度 ×\\times× 当前两条相邻的线截出的长度，直接数据结构维护可以做到 O(nlog⁡n)O(n\\log n)O(nlogn)（详细维护方法见例题）。 上面就是扫描线的流程，也就是把直线离散化然后对于被两条相邻的线截开的区域用数据结构维护。 Part 3 例题 P5490 【模板】扫描线 就是上面的模板，然后用线段树维护。 由于要维护当前覆盖层数 ≥1\\geq 1≥1 的点的个数，考虑记录区间 min⁡\\minmin 值、区间 min⁡\\minmin 值出现的线段的长度和区间不为 000 的所有线段的长度。 这个显然是可以维护的，前两个直接搞。后面的那个如果区间 min⁡\\minmin 值为 000，答案就是区间总长度 −-− 区间 min⁡\\minmin 值的线段长度。 如果区间 min⁡\\minmin 值不为 000，答案就是区间总长度。 时间复杂度：O(nlog⁡n)O(n\\log n)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;vector&gt;#define int long longconst int kMaxN = 2e5 + 5;int n, m, k;int x1[kMaxN], y1[kMaxN], x2[kMaxN], y2[kMaxN], b[kMaxN], lsh[kMaxN];int sum[kMaxN &lt;&lt; 2], mini[kMaxN &lt;&lt; 2], cnt[kMaxN &lt;&lt; 2], tag[kMaxN &lt;&lt; 2];std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; v[kMaxN];void discrete() { std::sort(b + 1, b + 1 + m), std::sort(lsh + 1, lsh + 1 + k); m = std::unique(b + 1, b + 1 + m) - (b + 1); k = std::unique(lsh + 1, lsh + 1 + k) - (lsh + 1); for (int i = 1; i &lt;= n; ++i) { y1[i] = std::lower_bound(lsh + 1, lsh + 1 + k, y1[i]) - lsh; y2[i] = std::lower_bound(lsh + 1, lsh + 1 + k, y2[i]) - lsh; v[std::lower_bound(b + 1, b + 1 + m, x1[i]) - b].emplace_back(y1[i], y2[i], 1); v[std::lower_bound(b + 1, b + 1 + m, x2[i]) - b].emplace_back(y1[i], y2[i], -1); }}void pushup(int x) { sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1]; if (mini[x &lt;&lt; 1] &lt; mini[x &lt;&lt; 1 | 1]) { mini[x] = mini[x &lt;&lt; 1], cnt[x] = cnt[x &lt;&lt; 1]; } else if (mini[x &lt;&lt; 1] &gt; mini[x &lt;&lt; 1 | 1]) { mini[x] = mini[x &lt;&lt; 1 | 1], cnt[x] = cnt[x &lt;&lt; 1 | 1]; } else { mini[x] = mini[x &lt;&lt; 1], cnt[x] = cnt[x &lt;&lt; 1] + cnt[x &lt;&lt; 1 | 1]; }}void addtag(int x, int l, int r, int v) { tag[x] += v, mini[x] += v; if (mini[x]) sum[x] = lsh[r + 1] - lsh[l]; else sum[x] = lsh[r + 1] - lsh[l] - cnt[x];}void pushdown(int x, int l, int r) { if (!tag[x]) return; int mid = (l + r) &gt;&gt; 1; addtag(x &lt;&lt; 1, l, mid, tag[x]), addtag(x &lt;&lt; 1 | 1, mid + 1, r, tag[x]); tag[x] = 0;}void build(int x, int l, int r) { if (l == r) { cnt[x] = lsh[r + 1] - lsh[l]; return; } int mid = (l + r) &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);}void update(int x, int l, int r, int ql, int qr, int v) { if (l &gt; qr || r &lt; ql) { return; } else if (l &gt;= ql &amp;&amp; r &lt;= qr) { return addtag(x, l, r, v); } pushdown(x, l, r); int mid = (l + r) &gt;&gt; 1; update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v); pushup(x);}void dickdreamer() { std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { std::cin &gt;&gt; x1[i] &gt;&gt; y1[i] &gt;&gt; x2[i] &gt;&gt; y2[i]; b[++m] = x1[i]; b[++m] = x2[i]; lsh[++k] = y1[i]; lsh[++k] = y2[i]; } discrete(); long long ans = 0; build(1, 1, k - 1); for (int i = 1; i &lt; m; ++i) { for (auto p : v[i]) { int l = std::get&lt;0&gt;(p), r = std::get&lt;1&gt;(p), c = std::get&lt;2&gt;(p); update(1, 1, k - 1, l, r - 1, c); } ans += 1ll * (b[i + 1] - b[i]) * sum[1]; } std::cout &lt;&lt; ans &lt;&lt; '\\n';}int32_t main() { std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); int T = 1; // cin &gt;&gt; T; while (T--) dickdreamer(); // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl; return 0;} 未完待续…","link":"/2023/06/28/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"APIO","slug":"APIO","link":"/tags/APIO/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"扫描线","slug":"扫描线","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"贪心","slug":"题解/贪心","link":"/categories/%E9%A2%98%E8%A7%A3/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"题解/二分","link":"/categories/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86/"},{"name":"数学","slug":"题解/数学","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"题解/数学/斯特林数","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"图论","slug":"题解/图论","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"},{"name":"字符串","slug":"题解/字符串","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"题解/数据结构","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"拓扑排序","slug":"题解/图论/拓扑排序","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"后缀自动机","slug":"题解/字符串/后缀自动机","link":"/categories/%E9%A2%98%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树","slug":"题解/数据结构/线段树","link":"/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计算几何","slug":"学习笔记/计算几何","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"扫描线","slug":"学习笔记/计算几何/扫描线","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E6%89%AB%E6%8F%8F%E7%BA%BF/"}],"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"关于","text":"一个菜鸡 OIer 的博客，主要记录一些题解和有趣的东西。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}]}